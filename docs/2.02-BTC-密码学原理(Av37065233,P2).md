**2.02-BTC-密码学原理(Av37065233,P2)**

首先我们讲一下比特币系统中用到的密码学原理。比特币被称为叫加密货币。

但其实加密货币是不加密的。区块链上所有的交易内容都是公开的，包括账户的地址，转账的金额都是公开的。比特币中主要用到了密码学中的两个功能，一个是哈希，另外一个是千名。大家应该都比较熟悉哈希函数的工作原理，密码学中用的哈希函数被称为cryptographic
hash function。

它有两个重要的性质，一个叫做cliresistance。

这个地方的可利刃是指哈希碰撞。如果有两个输入X和YX不等于Y但是比如说我们的哈希函数叫H算出来的HX等于HY那么这就叫做哈希碰撞。两个不同的输入算出来的哈希值是相等的。哈希碰撞是很常见的。像我们使用哈希表的过程中就会遇到哈希碰撞，不同的输入可能会被映射到哈希表当中的同一个位置。

一般来说哈希碰撞是不可避免的，因为输入空间是远远大于输出空间的。比如说我们有一个256位的哈希值。那输出空间有多大呢？所有哈希值的取值可能性就是二的256次方，输入空间就只有这么大。但是输入空间可以是无限大的，所以它是有任意多种树的可能性，按照歌农原理的话，必然会出现有两个输入被映射到同一个输出的情况。所以我们这里说的可Li人resistance，并不是说不会出现哈希碰撞，有的书上管这个性质叫做。

可丽人弗瑞这个说法我不是特别喜欢，因为它容易给人造成误解，好像是碰撞不会发生，实际上碰撞是客观存在的。他这个意思是什么呢？是说没有什么高效的方法，人为的去制造哈希碰撞。就给定一个X。没有什么好办法，你能找到另外一个Y使得S和Y的哈希值恰好相等。你没有什么高效的方法去找你硬要找的话，可以用蛮力求解的方法。比如说这个X和这个Y你就遍利所有输入的可能性。然后看看哪一个算出来哈希值正要相等，就意种这种叫做叫bruforth
sa。

便利书的所有可能取值，最后找了一个哈希值巧碰撞在一起的。但是如果这个输入空间比较大，比如说是对于一个哈希值是256位的话，实际上你要用这种方法去找的话，在实际中是不可行的。他的工作量实在是太大了。

那么client resistance这个性质有什么用呢？

它可以用来对一个message求digest。比如说我们有一个message叫M我们取它的哈希值HM这个哈希值可以认为是这个message
digest用来检测对这个message的篡改。比如说如果有人改这个message的内容，它的哈希值就会发生变化。那么这个clear
and
resistance性质就是说你找不到另外一个M1撇2，使得这个M1撇取哈希之后跟原来的哈希值恰好相等，所以没有办法能够篡改内容而又不被检测出来。

比如说你有一个很大的文件，你想把它存放到某个云存储服务上，将来你用到的时候再把它下载回来。你怎么知道你下载的版本跟你当初上传的版本是一样的呢？这就可以用到这个哈希函数的这个collision
resistance性质。在你上传这个文件之前，先算一个哈希值出来，这个哈希值存在本地，将来你下载之后，再算一个哈希值，跟原来你存的哈希值比较一下。如果是一样的话，那么说明上传的这个文件没有被篡改，下载的还是原来那个当初的版本。这就是collision
resistance的一个用处。

有一点大家注意，没有哪个哈希函数能够在数学上证明是可Li人resistant的。也就是说我们刚才讲这么重要的一个性质，从理论上是证不出来的，这个只能靠实践中的经验。有些哈希函数经过长期的实践检验，世界上有那么多密码学的专家，谁也没有能够找到人为制造哈希碰撞的方法。所以我们就认为这些哈希函数是可liresist的这就是实践经验。也有一些哈希函数，以前我们认为是可Li任resistant，但是后来大家找到了制造哈希碰撞的方法，这里面一个很著名的例子就是M
D five。

这个M D
five曾经是个很流行的哈希函数，大家原来以为它很安全，但是现在已经不行了。我们已经知道怎么去人为的制造哈希碰撞。

密码学用的哈希函数还有第二个性质叫做hiding。Hiding是什么意思呢？Heading是说哈希函数的计算过程是单向的，是不可逆的，给另一个输入X可以算出它的哈希值HX。但是从这个哈希值HX没有办法反推出原来的输入X就换句话说，这个哈希值没有泄露有关输入的任何信息，就叫做hiding。

当然其实你想一想，如果你想要知道这个输的话，也是有办法怎么办？还是用那种蛮力的方法，我把这个输入所有可能的取值遍历一遍，看看哪个哈希值跟这个相等。这就我能猜出来原来的输入是什么。所以蛮力求解是一种办法，heading这个性质成立的前提是这个输入空间要足够的大，使得这种蛮力求解的方法是不可行的。而且这个书的分布要比较均匀，各种取值的可能性都是差不多的。如果这个输入空间虽然是很大，但是绝大多数情况下取值都是集中在少数几个值，那么也是比较容易被破解的。Hiding这个性质有什么用呢？

它可以和这个可利resistance性质结合在一起，用来实现digital commitment。

这个digital commitment有时候也把它叫做。

Digital equivalent.

Of a sealed.

我们先说一下现实生活中所有的envelope是干嘛用的。比如说有一个人说他能够预测股市，可以预测第二天哪些股票会涨停。那怎么证明这个人预测的是不是准确呢？一种办法是这个人提前一天在电视台上公布预测结果，我预测明天某某股票会涨停。第二天收盘之后，看一下这个股票是不是真的涨停了，就知道预测准不准了。这样做有什么问题吗？

这好像是一种检验预测准不准的方法，有什么问题吗？刚才那个同学说的对，如果你预测结果提前公布了，可能会影响股市。就比如说这个人很有名气，大家觉得这是个股神，本来这只股票不会涨停了，他这么一公开预测，大家拼命的去买，结果它变成了涨停。当然了，反方向的情况也可能发生，就这支股票也许本来确实是要涨停的，有人想踢场子，你不是预测它涨停吗？我就不让它涨停，拼命的砸盘说都有可能发生，这说明一个什么道理？

预测结果不能够提前公开。但是如果预测结果不提前公开，你等第二天收盘之后再公开。那你怎么知道这个预测结果有没有被篡改过？你最后公开的结果是不是你提前一天做出来的？这个就要用到我们说的叫sal的envelope。你把你的预测结果写在一张纸上，放到一个信封里给封好了。这个信封要交给第三方的公证机构保管，等第二天收盘之后再把它打开，验证一下这个结果准不准。

大家听明白了吗？就是现实生活中still的amop就是这个地方。在电子世界里，我要有一个低级头，有的envelope我怎么实现呢？把这个预测结果作为输入X算出一个哈希值来，然后我把这个哈希值可以公布出去。因为我们有这个hiding的性质，所以你从这个哈希值不知道预测结果是什。

么然后第二天收盘之后，我再把预测结果公布出去。因为有这个可liresistance性质，所以我这个预测结果是不可能篡改的。你要是改的话，就跟当初公布的这个哈希值是对不上了。大家听明白了吗？这就起到一个se的op的功能。

实际操作中有一些细节要注意，就我们说hiding这个性质的前提是什么？输入空间要足够大，然后分布要比较均匀。如果这个输入不满足这个性质，像我举的这个例子当中，预测第二天哪只股票会涨停，这股票一共就那么几千只，对吧？

输入空间不是足够大，那么常用的方法是把这个输入后面拼接一个随机数，然后再一起取。哈希就是这个时候不是XX后面拼一个随机的叫。然后整个取哈型。这个n是我们选取的一个随机数，保证这样拼接之后整个输入是足够随机的，然后分布也是足够均匀的这实际中操作要注意的一些细节。大家有什么问题吗？

除了密码学中要求的这两个性质之外，比特币中用到的哈希函数还要求第三个性质，叫pulo
friendly。

他这个意思是说。哈希值的计算。事先是不可预测的，你光是看这个输入，你很难猜出来他最后的哈希值是什么。所以如果你想要你算出来的哈希值是落在某个范围之内的那没有什么好办法，你就只能是一个一个输入去试看，哪个输入算出来恰好是落在要求的那个范围之内。

比如说你想得到一个哈希值，前面K位都是0，你要这样的哈希值0。前面是一串零，后面可以是任意的。整个是256位的，必须以K个零开始。那什么样的输入会算出这样的哈希值呢？不知道这个pudle
friendly性质是说你事先是不知道的，哪个输入更有可能算出这个哈希值呢？那你要得到这个哈希值就一个一个去试，没有什么捷径。这个性质为什么叫puaddle
friendly？

后面我们讲到比特币这个挖矿的过程，大家可能听说过挖矿这个词。挖矿实际上就是找一个n找这么一个随机数。这个n呢跟区块的块头里的其他信息合在一起作为输入，取出一个哈希来，那个哈希值要小于等于某个指定的目标阈值。

比特币是区块链，对吧？区块链就是一个区块组成的链表，每个区块有一个块头，这个block
header block
header里面有很多的域，其中有一个域是我们可以设置的随机素。那么挖矿的过程就是不停的去试各种随机数。使得整个block
header取哈希之后落在指定的范围之内，小于等于1个ta的space。就比如说这个是整个的输出空间output
space，我们要求这个算出的哈希值只有落在前面这一点才是合法的，这个是target
space。

这个part
friendly的性质是说这个挖矿的过程没有捷径，只能靠不停的去试大量的n才能找到符合要求的解。所以这个过程才可以用来作为工作量证明，叫做。

Proof of a work.
你挖到矿了，找到符合要求的烂色，一定是因为你做大量的工作，因为没有别的捷径。这里大家注意，虽然这个挖矿的过程需要很多的工作量才能找到一个符合要求的。但是一旦有人找到了这样一个n发布出去之后，其他人要验证这个l是不是符合要求是很容易的，只要算一次哈希值就行了。就这个n作为hi的一部分算一次哈希值，看它是不是小于等于这个目标阈值，挖矿很难验证，很容易，这个性质叫做。

Difficult to solve. But easy to verify.

我们设计这种manding爬走的时候要注意这个性质。

比特币中用的哈希函数叫做。Sh 256。这个sha的意思是。Secure hash.
Algorithm.

我们说的这三个性质它都是满足的。有的同学可能觉得这个puzzle
friendly跟这个可liresistance好像有点像。就这两个性质是有一定的联系，但不是完全一样。

好了，我们说比特币中用到了密码学的两个功能，一个是哈希，一个是签名。到这里我们已经把第一个功能哈希讲完了，我们下面讲签名。要讲签名的话，我们得先讲一下比特币系统中的账户管理。日常生活中，如果你想开个账户的话，你怎么办？

你带上证件去银行办理开户手续，对不对？这就是中心化系统的账户管理方式。比特币是去中心化的，它没有这种银行之类机构，那怎么开账户呢？每个用户自己决定开户，不需要任何人批准。开户的过程很简单，就是创立一个公钥和私钥的对。

在本地创立一个公司药对就是一个账户，这个就在比特币中代表了一个账户。公司要这个概念是来源于非对称的加密体系，叫做。

Is the metric. In encryption. Algorithm.
最早的加密体系是对称的，就是没有这个A最早的叫做symmetric encryption .

algorithm。

比如说两个人之间要进行通讯，我要把某个信息发给你，但是这个通讯的网络是有可能被窃听的那怎么办呢？咱们俩事先商量好一个密钥就一个叫encrtion。

我把这个信息加密之后发给你，你收到之后再用这个密钥解密。因为这个加密和解密用的是同一个密钥，所以这个叫做对称的加密体系。他这个前提是假设有某种安全的渠道能够把这个密钥分发给通讯的双方。因为你显然不能够说把这个密钥以明文的形式在网络上传输。我们假设网络本身就是不安全的，有可能被窃听的。这个其实是对称加密体系的一个弱点，就是密钥的分发不是很方便。

解决这个问题，非对称加密体系就提出来，我们不是用一个密钥，而是用一对密钥，就有一个公钥和一个私钥。加密用的是公钥，解密用的是私咬。就比如说我要把一个信息传给你，我用你的公钥给这个信息加密。你收到之后，再用你的私钥解密，得到原来的信息。大家注意这个加密和解密用的是同一个人的公钥和私钥，都是这个接收方的公钥和私钥。这有什么好处呢？

这个公钥是不用保密的，加密用的公钥是不用保密的。你可以告诉所有的人，有的人他的home配置上就列出过他的PG
P public
p所大家都可以知道私钥是要保密的，因为它是解密是用私钥解密的。但是私钥只要保存在本地就行了，不用传给对方。就给你通讯的那个人不需要知道你的私咬，他是用你的公钥加密的。你要回复他的话，你再用他的公钥加密，都不需要知道对方的私钥，这就解决了对称加密体系当中密钥分发不方便的问题。

比特币系统中，你要创建一个账户，就在本地产生一个公钥和私钥，一对公钥和私钥。这个公钥就相当于你的银行账号，别人要给你转账，只要知道你的公钥就行了。这个私钥相当于你的账户密码，知道这个私钥就可以把这个账户上的钱转走。

有一个问题，我们前面说比特币系统是不加密的，他叫要加密货币。它其实是不加密的，信息都是公开的那我要这个公钥和私钥干嘛呢？实际上是用来做签名，就我们讲的第二个功能签名。

比如说我要转十个比特币给你，十个比特币有很多钱，我很慷慨转给你。然后我把这个交易发布到区块链上，别人怎么知道这个交易确实是我发起的呢？会不会是有人冒名顶替，想偷偷的把我的账上的钱转走了。这就需要我在发布这个交易的时候，要用我自己的私钥对这个交易签名。其他人收到这个交易之后，再用我的公钥去验证这个签名的正确性。大家听明白了吗？签名用的是私钥验证签名用的是这个人的公钥，仍然都是同一个人。

听到这里，大家可能有一个疑问，既然每个人是独立的产生账户，本地独立的生成公司要对不需要任何人批准。那么万一两个人生成的公司药对恰好相同怎么办？就比如说有人想偷取比特币，一种方法是就不停的产生大量的公司药。然后对比一下我产生的这个公钥跟区块链上某个已有的公钥是不是相同。如果是一样的话，就可以用对应的私钥把这个账上的钱给偷走。

这种攻击方法，从理论上说好像是可以的，但是实际当中是不可行的。如果你是256倍的哈希值的话，产生相同的公司药的可能性是微乎其微的。即使你有一台超级计算机，别的事情都不干，每天就不停的产生大量的公司。要对出现两个人的公司药，对相同的概率也是可以忽略不计的。这个概率比地球爆炸的概率还要小，就到目前为止还没有发现哪个人用这种方法能够攻击成功的先例。这里要强调一点，就是我们这里假设产生公司药的时候，是有一个好的随机源，这叫做。

A good source of randomness.
生成公司要的过程显然是随机的。如果不是随机的话，那等于大家都生成同样的公司用了。如果你选取的这个随机源不好的话，那么前面的分析就不成立了。比如说就有可能出现两个人的公司药对生成的是一样的。

比特币中用的这个签名算法，不光是生成公司要的时候要有好的随机源，之后每一次签名的时候也要有好的随机源。只要有一次签名的时候，用的随机员不好的话，就有可能泄露私钥，然后就全完了。所以这一点大家一定要特别注意。

我们今天讲的两个功能，一个是哈希，一个是签名，这两个功能是可以结合起来用的。比特币系统当中，一般是先对一个message取一个哈希，然后再对这个哈希石签名。我们要讲的密码学部分就到这里了，大家有什么问题吗？
