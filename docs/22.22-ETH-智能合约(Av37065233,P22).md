**22.22-ETH-智能合约(Av37065233,P22)**

今天我们讲智能合约，智能合约是以太坊的精髓，也是以太坊和比特币的一个最大的区别。智能合约的本质是运行在区块链上的一段代码。这个代码的逻辑就定义了智能合约的内容。智能合约的账户里保存了这个合约当前的运行状态。我们前面讲过，合约的状态包括接下几项，有当前的余额交易次数、合约代码和存储。存储的数据结构是一和MPT。智能合约的代码一般是用solidity语言来编写的，语法上跟JavaScript是很接近的。所以熟悉JavaScript的人学solidity是比较容易的。

这个图显示了智能合约的代码结构。第一行首先声明一下所使用的sollo地铁的版本号，不同版本的solidity语言在语法上有一些小的差别。Solidity是面向对象的编程语言。这里的这个contract类似于C加加当中的类class，我们这个cont的定义了很多状态变量。Solidity是强烈性语言，叫strongly
typed。这里的类型大部分跟普通的编程语言，像C加加之类的是比较接。比如说这个U
int，这个U
int类型是unsign的int。无符号的整数这个address类型是sel语言中所特有的，我们后面会讲一下这个地址类型的成员变量和成员函数。

接下来是两个event事件，这个事件的作用是用来记录日志的，也就是说用来打log的。第一个事件是highest
bincrease拍卖的最高出价增加了。就我们这个代码的例子是一个网上拍卖的例子，拍卖的具体规则我们后面会讲。如果出现某个人出一个新的最高价，那么我们记录一下这个参数是address，金额是amount。第二个事件是pay
to beneficiary，它的参数是赢得拍卖的这个人的地址，这个win
ner以及他最后的出价amount。

索雷特语言跟普通的编程语言比，它有一些比较特别的之处。比如说我们上面这个mapping，我们可以看到这个mapping是一个哈希表，保存了一个从地址到unsign
int的一个映射。那么sol雷语言中的哈希表的一个比较奇怪的地方是它不支持便利。如果你想毕立哈希表中的所有元素，那么你自己需要想个办法记录一下哈希表中有哪些元素。我们这里是用这个B的这个数组来记录的，soli语言中的数组可以是固定长度的，也可以是动态改变长度的。那么这里是一个动态改变长度的数组，比如说你要想从往那个数组里增加一个元素。

就用push操作be点push
be得就新增加一个出价人。在书主的末尾，你要想知道这个数组有多少个元素，可以用它的length语。

如果这个地方是一个固定长度的树主的话，那么需要在这里写明这个数主的长度。比如说。

这个就是一个长度为1024的数组。再往下是它的构造函数。Soli语言中定义构造函数有两种方法，一种方法就是像C加加中的构造函数一样，定义一个与这个contract同名的函数，这个函数可以有参数，但是不能有返回值，这是一种方法。那么新版本的soli语言实际上更推荐的是用我们这里的一种方法，就是用construct来定义一个构造函数。这个构造函数只有在合约创建的时候会被调用一次。接下来是三个成员函数，这三个函数都是public，说明其他账户可以调用这些函数。我们注意就是这个B的这个函数，这里标志有一个叫payable，这个我们后面会解释一下是什么意思。就这个代码结构，大家还有什么问题吗？

对construc只能有一个构造函数，只能有一个，对代码上的字能看清楚吗？还可以是吧？好，我们说一下怎么调用智能合约。调用智能合约其实就跟转账是类似的。比如说A发起一个交易，转账给B如果B是一个普通的账户，那么这就是一个普通的转账交易，就跟比特币当中的转账交易是一样的。如果币是一个合约账户的话，那么这个转账实际上是发起一次对币这个合约的调用。具体调的是这个合约中的哪个函数呢？是在数据域留说明的，就这个date域。

那在德域中说明。我们这个例子当中，三的address是发起调用的账户的地址，to
contract address是被调用的合约的地址。调用的函数这是transaction
data左下角这个地方给出要调用的函数。如果这个函数是有参数的话，那么参数的取值也是在这个data域里。说明了我们上一页看的那个代码样例，那个网上拍卖的样例当中，三个成员函数都没有参数。但是有的成员函数是可以有参数的，那么中间那一行是这个调用的参数。

这个value是说我发起这个调用的时候转过去多少钱，这里是零。我这个调用的目的仅仅是为了调用它的函数，并不是真的要转账说它这86是0。Gas
used是我这个交易花了多少汽油费，就gas used gas
price是单位汽油的价格，gas
limit是这个交易我最多愿意支付多少汽油。我们后面会详细讲汽油费的事情，大家有问题吗？

除了一个外部账户可以调用一个合约函数之外，一个合约也可以调用另外一个合约函数。调用的时候有几种方法，这种方法我们显示的是直接调用，就由A和B两个合约。A这个合约就只是写条log就我们前面说过一万的是定义一个事件，这叫local
emit
in。这个local就用emit这个操作来调用这个事件的作用。这个emit语句的作用就是写一个log对于程序的运行逻辑是没有影响的。那么B这个合约，这个函数参数是一个地址，就是A这个合约的地址。然后这个语句把这个地址转换成A这个合约的一个实例，然后调用其中的负这个函数。大家听明白了吗？

另外我说明一点，就以采访中规定一个交易只有外部账户才能够发起，合约账户不能够自己主动发起一个交易。所以这个例子当中实际上是需要有一个外部账户调用了合约B当中的这个函数，括A负directly这个函数。然后这个函数在调用A这个合约当中的负函数。

第二种调用方式是用我们这个地址类型address点括这个方式。这个时候第一个参数是要调用的那个函数的签名signature。然后后面跟着是调用的参数。

这种调用方法跟上一种直接调用的方法相比，一个区别是对于错误处理的不同。上种方法就比如说我们这个时候调用的时候，如果你调用的那个合约在执行过程中出现错误，那么会导致发起调用的这个合约也跟着一起回滚。就比如说这个例子中，如果A在执行过程中出现什么异常，再抛出一个异常，会导致B这个合约也跟着一起出错。而这个扩这种方法，address点core这种形式如果在调用过程中被调用的合约抛出异常，那么这个扩函数会返回force，就表明这个调用是失败的。但是发起调用的这个函数并不会抛出异常，而是可以继续执行，这就两种调用方法在错误处理上的区别。

还有一种调用方法是delegate扩，这个跟刚才讲的这种扩的方法基本上是一样的。一个主要的区别就是get
call不需要切换到被调用的合约的环境中去执行，而是在当前合约这环境中执行就可以了。比如说就用当前这个合约的账户余额存储之类的。大家有问题吗？

好，没有问题。我们再看一下我们刚才讲过的这个代码的结构。我们说这个B的函数这里有一个payable，另外两个函数都没有。那这是什么意思呢？就是以太坊中规定，如果你这个合约账户要能接受外部转账的话，那么必须标注成payable。

那么这个例子中这个B的函数是什么意思？我们这是一个网上拍卖的合约，B的函数是用来进行竞拍出价的。比如说你要参与拍卖，你说你出100个亿台币，那么你就调用这个合约中的这个B的函数。所以他这个拍卖的规则是你调用这个B的函数的时候，要把你拍卖的出价那100个以台币也发送过去，存储到这个合约里，锁定那里，一直到拍卖结束。

大家听明白了吗？

就避免有的人就是凭空出价，你说你出好多以台币，出1万个以台币，实际上你没这么多钱。所以你要拍卖的时候，要把你出的价钱要发到职能合约里。锁定权。所以这个B的函数要有能够接受外部转账的能力，所以才标注一个payable这个尾子座这个函数。第二个尾子座函数它就没有payable
with
the座是干嘛用的呢？就拍卖结束了，出价最高的那个人赢得了拍卖，其他人没有拍到想要的东西，那么可以调用韦的弱这个函数，把自己当成出的价钱，就是原来闭得的时候锁定在智能合约里的那些以太币再取回来。因为这个的目的不是为了真的转账，他不需要把钱转给这个智能合约，而仅仅是通过调用这个尾字做函数，把当初锁定在智能合约里的那部分钱取回来。所以他没必要用payable。

就比如这是我们刚才看的那个例子，大家还记得吗？转账交易的例子。这个时候这个value就是0，这个交易就是属于并没有真的把钱转过去。所以这个contract
to contract address这个函数就不用定义成payable。

以太坊中凡是要接受外部转账的函数都必须标志为payable。否则的话如果你给这个函数转过去钱的话，会引发错误处理，会抛出异常。如果你不需要接受外部转账，这个函数就不用写成退able。所最后有一个比较特殊的函数叫for
back函数，大家看一下这个函数的定义。

这个函数既没有参数，也没有返回值，而且也没有函数名，是个匿名函数。我们说这是for
back函数，但是for
back这个关键字也没有出现在这个函数名里面。他什么意思呢？

就我们前面说你调用一个合约的时候，A调用B这个合约。要在转账交易里的data域说明你调用的是B这个合约当中的哪一个函数，对不对？那如果A给这个合约B转了一笔钱，没有说明调用的是哪个函数，那怎么办呢？就比如说它的data域是空的，那么这个时候缺省的就是调用这个for
back函数。就是为什么管它叫for back函数？因为没有别的函数可调了，就掉它。

还有一种情况就是你要调的函数不存在在你的那个data域里。你说你要调这个函数，而实际这个合约当中，它没有这个函数，那怎么办呢？也是调用这个for
back函数。这就是为什么这个函数没有参数，也没有返回值，它没法提供参数。对于这个four函数来说，也可能需要标注payable这个关键词。

如果这个for
bug函数需要有接受转账的能力的话，那么也需要写明是payable。这个一般情况下都是写成payable。如果你这个合约账户没有任何函数标志为payable，包括for
bu函数也没有标志成payable，那么这个合约没有任何能力可以接受外部的转账。大家听明白了吗？如果这个合约没有for
bug函数，或者是它有for
bug函数没有写payable，那么其他人如果就往这个合约里转一笔钱，别的什么都不说，对域是空的，就会引发异常。有问题吗？

不是feedback，back和payable都是在合约定义的时候写的。我给你转账的时候，我不用写payable，也不用写for
back。不就是说我如果给你转账，别的什么都不写，没有调用你其中的任何一个函数，那么就自动会调用这个for
bu函数。这个for bu函数不是必须定义的，就是你这个合约可以没有for
bu函数。如果没有这个函数的话，出现前面说的那几种情况就会抛出异常。就比如我给一个合约转账，没有说掉哪个函数，那个合约也没有定义for
bu函数，那么这个转账就是错误的，就会引发错误处理。

另外只有合约账户才有这些东西，这以前有的同学学的有些混淆。外部账户跟这个都没关系，外部账户没有代码，没有什么for
back，不for
back，也没有什么payable，payable他根本就没有代码，只有合约账户才有这些东西。另外还有一点，我们说转账金额是可以是零，对吧？但是汽油费是要给的这是两码事儿。转账金额是给收款人的，你转给谁？这个金额是给谁的？汽油费是给发布这个区块的矿工的，转账金额可以是0。但汽油费如果你不给的话，矿工不会把你这个交易打包发布到区块链上。

我们到目前为止讲的都是智能合约的调用，我们讲两种调用方法。那智能合约是怎么创建的呢？是由某一个外部账户发起一个转账交易，转给0X0这个地址。就这个地址，然后把这个要发布的合约的代码放到这个date域里面，大家听明白了吗？就你要创建一个合约，你发起一个转账交易给零这个地址转账的金额都是0，因为你实际上不是真的想转正，你只是想发布一个智能合约。你发布那个智能合约的代码就放在这个数据里就行了。

然后合约的代码写完之后，都是要编译成白的扣的，然后运行在这个叫evm上isvirtual
machine。大家听说过jvm吧？Java virtual
machine听说过吧？这位M的目的是什么？为什么要加一个这位？增强可移植性对吧？EM也是类似的设计思想，通过加一层虚拟机对智能合约的运行提供一个一致性的平台。所以evm有的时候叫做word
wide computer，全世界的一个计算机1M的寻址空间是非常大的。

是256位的，像我们前面讲那个U int
uns的int就是256位。你们平时用的机器是多少位的？以前是32位的，现在很多服务器是64位的，跟这个256倍的是没法比的。

然后我们现在讲一下汽油费。我们如果比较一下这个比特币和以台坊这两种区块链的编程模型，他们的设计理念是有很大差别的。比特币的设计理念是简单，这脚本语言的功能很有限，比如说不支持循环。而以太坊它需要提供一个图灵完备的编程模型，就这里写的touring
complete的programming
model。很多功能在比特币平台上实现起来很困难，甚至是根本实现不了。而到以太坊平台上就实现起来就很容易。

当然了，这样也带来一个问题，比如说出现死循环怎么办？当一个全节点收到一个对智能合约的调用，怎么知道这个调用执行起来会不会导致死循环？有什么办法呢？

没有办法，这实际上是个什么问题？

停机问题对吧？Hoting problem.
停阶问题是不可解的。这里大家注意一点，这个问题不是NPC的。

Npc的问题是可解的，只不过它没有多项式时间的解法。很多nc问题有很自然的指数时间的解法，比如说哈密尔顿回路问题，就判断一个图有没有哈密尔顿回路，这个其实是很容易解的。就你想到一个解法是很容易的，如果你不考虑复杂度的话，你觉得怎么写？

把所有的可能性每举一遍，比如说你有N个顶点。那么N个顶点的排列是N的阶乘这么多个组合，把每一个组合检查一下是不是构成一个合法的回路，就知道它有没有哈尔回路。所以哈密尔顿回路问题是可解的，只不过这个解的复杂度是指数级的。而停机问题是根本就不可解的。从理论上可以证明，不存在这样一个算法能够对任意给定的输入程序判断出这个程序是否会停机，那这是不可解的。

那怎么办呢？办法就是把这个问题推给发起交易的那个账户。就以太坊引入了汽油费机制，你发起一个对智能合约的调用，你要支付相应的汽油费。我们看一下，这是一个交易的数据结构。

这个account lines就是这个交易的序号，用于防止我们前面说的那种replay
attack。这个price和gas limit就是跟汽油费相关的。Gas
limit是我这个交易愿意支付的最大汽油量，price是单位汽油的价格，所以这两个乘在一起就是这个交易可能消耗的最大汽油费。这个recient的是收款人的地址，这个转账交易转给谁的收款人地址amount是转账金额，把amount这么多的钱转给这个recipient。所以我们也可以看到交易当中的汽油费跟这个转账金额是分开的。Pay
load的就是我们前面说的data域用于存放调用的是这个合约中的哪一个函数，这些函数的参数取值是什么？都在payload里面。

当一个全节点收到一个对智能合约的调用的时候，先按照这个调用中给出的gas
limit算出可能花掉的最大汽油费。然后一次性的把这个汽油费从这个发起调用的账户上扣掉。后再根据实际执行的情况，算出实际花了多少汽油费，多退少补。其实不叫多退少补，如果你的汽油费不够的话，会引起回滚。就一次性先把这个汽油费都扣掉。

不同的指令消耗了汽油费是不一样的。一些简单的指令，比如说加法减法消耗了汽油费是很少的。复杂的指令消耗的消费就比较多，比如说曲哈西这个运算一条指令就可以完成，但是汽油费就比较贵。除了计算量之外，需要存储状态的指令消耗的汽油费也是比较大的。相比之下，如果你仅仅是为了读取公共数据，那么那些指令可以是免费的。

然后我们说一下这个以太坊中的错误助理。以太坊中的交易执行起来具有原则性。一个交易要么全部执行，要么完全不执行，不会只执行一部分。大家听明白了吗？要么完全执行，要么完全不执行，不会执行到一半。这个交易既包含普通的转账交易，也包含对智能合约的调用。所以如果在执行智能合约的过程当中出现任何错误，会导致整个交易的执行回滚退回到开始执行之前的状态，就好像这个交易完全没有执行过。

什么情况下会出现错误呢？一种情况就是刚才我们说的汽油费。如果这个交易执行完之后，没有达到当初的gas
limit，那么多余的汽油费会被退回到这个账户里。就一开始的时候不是按照最大的gas
limit把汽油费扣掉了吗？如果最后运行完了，还有剩下来的，那么实际上是用了多少汽油，收多少钱，剩的可以退回去。相反的，如果执行到一半，这个gas
limit已经都用完了。那么这个时候这个合约的执行要退回到开始执行之前的状态，这就是一种错误处理。而且这个时候已经消耗掉的汽油费是不退的。大家想一下为什么要这么设计？

执行的状态要回滚，但已经耗掉汽油费是不退的。

你说的对，要不然的话就会有恶意的节点，可能会发动dof service
tag，就可能他发布一个计算量很大的合约，然后不停的调这个合约。每次调用的时候给的汽油费都不够，反正最后汽油费还会退回来。对我来说没有什么损失，但是对矿工来说是白白浪费了很多的资源。就是为什么说如果汽油费不够的话，执行到一半会回滚，花掉的汽油费是不退的。

除了这个汽油费不够的情况之外，还有一些时候会引起错误处理的。比如说这个assert语句和require语句，这两个语句都是用来判断某种条件，如果条件不满足的话，那么就会导致抛出异常。A
set语句一般来说适用于判断某种内部条件，就有点像我们C语言中的Asser是一样的。这个require语句一般用来判断某种外部条件。比如说判断函数的输入是否符合要求。这里就给一个简单的例子，这个B的这个函数，这个竞拍的函数判断一下当前时间，这个law是小于等于拍卖的结束时间。如果符合条件的话，继续执行。如果不符合的话，拍卖都已经结束了，你还在出价，那么这个时候就会抛出异常。

第三个语句是这个rever这个rever是无条件的会抛出异常。如果你执行到这个rever这个语句，那么它自动的就会导致回滚。这个早期的版本里他用的是。Through这个语句，新版本的solidity建议改用revert这个语句。

最后一点大家注意，就是solidity里边当中没有这种try
cache这种结构。就有的编程语言像Java用户可以自己定义，出现异常后怎么办？它有几种try
catache扫d ity址当中没有这个结构。

好，我们前面说智能合约执行过程中出现错误会导致回滚。如果是嵌套调用一个智能合约，调用另外一个智能合约。那么被调用的那个智能合约出现错误，是不是会导致发起调用的智能合约也跟着一起回滚呢？这个所谓的叫连锁式回滚。这个不一定，这个取决于调用这个智能合约的方式。如果这个智能合约，比如说我们前面讲过两种方式是直接调用的话，那么它会触发连锁式的回滚，就整个交易都会回滚。如果调用的方式是用，比如说扩这种方式，这里没有写前面讲那种扩的方式。它就不会引起连锁式回滚，只会使这个当前的调用失败返回一个force的返回值。

最后注意一点，有些情况下从表面上看，你并没有调用任何一个函数。比如说你就是往一个账户里转账，但是如果这个账户它是个合约账户的话，你转账这个操作本身就有可能触发对函数的调用。大家想想为什么？因有four
bu函数，这就是一种嵌套。调用一个合约往另一个合约里转账，就可能调用这个合约当中的for
bu函数。

有问题吗？

你大概是就是这个清仓调。

对那覆盖的是吧？我们前面说过函数调样的方式有两种。在函数里面去调出那个行列两那那这个相当调会调出。

不，这取决于你是怎么给他转账，就你转账的时候也有不同的方法去转账。比如说像send
and或者是transfer是一种方式，后你用括点value也是另一种方式，它不同的方式会有不同的效果实现。

会有指。

明。就是有就是我们下面会讲address这个类型的成员函数，它成员函数里会有这些区别。比如说用扩点value就属于不会引起连锁式回滚。就是扩点86的话，如果这个调用失败了，比如说你给合约转账，那个合约里没有for
bu函数，你也没有说掉哪个函数。那么这个括本身就会返回force，但是不会引起连锁式回滚。

这是我们当初看的这个block
header的数据结构，大家还记得吗？我们以前把这个数据结构都讲过一遍。

我们想说的是什么呢？就这个地方有一个gas limit和gas
used，这两个域也是跟汽油费相关。Gas use的是什么意思？Block header里的gas
used是这个区块里所有交易所消耗的汽油费，加在一起就是gas used。那gas
limit是什么意思？

你是这么觉得的这正常人的想法就是这个区块里所有交易的gas
limit加在一起就是这个区块块头里的gas。这种直观上的想法其实不是这样的，我跟你讲一下它的用意是什么。发布区块需要消耗一定的资源，对吧？那么我们要不要对这个区块消耗的资源有一个限制？比特币当中对于发布的区块也是有一个限制，是什么限制？大小的限制最多不能超过一兆，因为你发布的区块如果没有任何限制，那么有的矿工可能把特别多的交易全都打包到一个区块里面，然后发布出去。这个超大的区块在区块链上会消耗很多的资源，所以它规定每个区块最多不能超过一兆。

就比特币的交易是比较简单的，基本上你可以用交易的字节数来衡量出这个交易消耗的资源有多少。但以太坊中如果这么规定是不行的，因为以太坊中智能合约的逻辑很复杂，有的交易可能从字节数上看是很小的，但是他消耗的资源可能很大，比如说他可能调用别的合约之类的，所以怎么办呢？我们要根据这个交易的具体操作来收费，这就是汽油费。所以这个gas
limit是什么意思呢？

它是这个区块里所有交易能够消耗的汽油的一个上限。大家听明白吗？这个不是说把区块里每个交易的gas
name的加在一起，如果那样的话就等于没有限制。因为每个交易的gas
limit是发布交易的。这个账户你自己定的，你定多少是你自己说了算了。但是我这个区块中的所有交易，实际能够消耗的汽油是有一个上限的，不能无限的消耗。否则的话你也可能发布一个对资源消耗很大的一个区块数据，那对整个系统的运行是没有好。大家听明白吗？这个gas
limit什么意思？

就是说他的这个交易被打包了，成为一个区块再去执行再说，先去执行再打去。

这个问题问的非常好，实际上是我待会儿想问的一个问题。我们先稍微放一下，其他同学听明白他问什么了吗？我们待会儿回顾一下。

好，这个gas
limit我还要说明另外一点，就它跟比特币的区别。比特币我们说限制资源是按照大小来限制的，一兆的上限，而且这个一兆的上限是固定了的，是写死在协议里面的，就是遗诏。有些人认为遗诏太小了，而且有的分叉臂的产生就是因为想提高这个上限。以太坊中也有一个上线这个gas
limit，但是每个矿工在发布区块的时候，可以对这个gas
limit进行微调。它可以在上一个区块的gas
limit的基础上上调或者下调1024分之1。

比如说如果出现像比特币那种情况，我们大家都觉得这个gas
limit不行，设的太小，这个协议写的不好。那轮到你发布区块的时候，你可以增加1024分之1。大家不要觉得好像这个比例很小，1024分之1听起来很小。以太坊的出块速度很快，十几秒就是个新的区块。所以的话如果大家都觉得当前的gas
lim的太小，那么很快就可以翻一翻。

当然也可能下调，就也可能有的矿工认为gas
limit太大了，需要下调。所以这种机制实际上求出的gas
limit是所有矿工认为比较合理的gas
limit的一个平均值。大家听明白了吗？有的矿工可能认为gas
limit要上调，有的可能认为下调。那么每个矿工在获得记账权之后，就按照自己的意愿进行这种上调或者下调的微调。所以最后整个系统的gas
limit就趋向于所有矿工的一个平均意见。

下面我们说这个receive数据结构。说的是C的数据结构之前，我们回过来回答一下刚才那个同学的问题。假设某个权节点要打包一些交易到一个区块里面，这些交易里有一些是对智能合约的调用，那么这个权节点是应该先把这些智能合约都执行完之后再去挖矿呢？还是说应该先挖矿获得了记账权，然后再去执行这些职能合约？先把。

框放到区块上，再有一个指定的。你如果先去执行。

再去防他去块糖。因为有很多。

矿工都在挂岛，如果大家都去执行。好多人可能都去转了，然后大家又没有同步做交流，说谁干这个事儿，谁不干这个事儿。

大家听明白他的逻辑了吗？他认为应该先挖矿，确认我有权利发布区块，然后再执行智能合约。然后你给出的理由是比较奇怪的一个理由，说如果先执行的话，也不知道谁会挖矿，可能很多人都执行了同一个智能合约，一笔转账操作可能转了好几次，你是这个意思吗？对，这个其实我们要注意是。

理解清楚这个区块链的工作原理。区块链里有一笔转账交易发布上去的话，本来就是需要所有的全节点都执行的。这个不是浪费，也不是一种出问题了。就是所有的全节点要同步状态，大家都要在本地执行这个转账交易。如果要有一个全念点不执行那就出问题了。那他的状态跟别人状态是不一样的，比特币也是一样的。比特币你发布一个交易到区块链上，也是要所有的权节点都得执行这个转账交易。

要不怎么更新ut XO？

其他同学有什么看法吗？

别人都没意见。

他是需要汽油费的。

就这意思。对。

但是我不知道这个智能合约是被谁执行。我假定是这个矿工来执行，那么就说我收到这个交易之后，一个矿工收到这个交易，他会执行这个这能所以他就会收取那个那个汽油费。另外一个矿工他可能在一个另外一个阶段他也收到了这个，他也需执行定制，那么他也要收取汽油费，可能这个最后的账户的操作可能只有一次，但是汽油费按照这个状态的话，可能被两个孔龙或者更多的恐龙都会收取。

吸功大家听明白了吗？如果他就是你，你还认为应该是先挖矿，然后再执行智能合约。否则的话可能每个人都执行合同合约，执行智能合约要收取汽油费，就是从发起交易那个人的账户上要收汽油费。如果有多个人都执行这个智能合约，会把这个汽油费收很多份。

最后你把那个牌扒住去去，我觉得应该。

合约上最后你把发布出去，可约让我才会把钱拿到。

你说这个不是问题，但是你给的理由是这样的。你说因为是这个汽油费的收取，不是矿工直接收取，是合约收取的。然后合约的话，一开始先把汽费打到合约账户上，然后你挖到矿发布出去之后，合约账户再把钱打到你的账户上。不是。好，我们那往回退一步，我们先不回答这个问题。我们说在全节点收到一个对合约的调用的时候，要一次性的先把这个调用可能花掉的最大汽油费，从发起这个调用的账户上扣掉。这个具体是怎么操作的？或者说就是按照你刚那个同学的问题，如果有几个全节点都要执行这个交易，那我那岂不是大家都要扣一分？

全节点应该不止。

悬念点是不止一个矿工也不止一个。不，我们这个课上有时候不是很严格的区分全节点和矿工。我们以前讲比特币的时候讲过一下，就是一个全节点可能用于验证交易，后面可能跟着一大堆矿工光是进行挖矿。比特币中有些矿工就光是算哈希值，他就有一个ac个矿机不停的算哈希值。它没有全节点的其他功能，像验证交易，监听交易，验证发布的区块，它可能都是outsource给那个全节点做了。就我们说的时候，有时候不是很区分这两个概念，全节点和矿工。

有一个问题就是他一个收到一个正能回应，然后我一个圈击点要克服他的一个机会。

所以这个过程我们要仔细讲一下汽油费是怎么扣的。我们还大家还记得三棵树吗？

那不叫账户数，叫状态数、交易数和收据数。这个实际上是收据数的收据的结构。每个节点这三棵树是在哪儿的？

状态数在全节点交易数涨在哪是吧？也是在全节点收据书。还是在全节点，就这三棵树都是全节点在本地维护的数据结构。然后记录了什么？比如状态数记录什么，每个账户的状态，包括账户余额。

所以扣汽油费的时候，实际怎么扣的，我这个学金点收到这个调用的时候，从我本地维护的数据结构里把他账户的余额减掉就行了。听明白了吗？他如果余额不够的话，这个交易就不能执行，就一次性要按gas
limit把它这个余额减掉。如果他没有这么多钱就不执行，执行完之后如果有剩的，再把他的余额给加回去一点。所以你说那个问题是什么情况？多个全节点大家每人扣一份，多个全节点每个人在他本地的数据结构里扣一下而已。

刚才那个同学说的也不对，你说是一个先发到合约账户，合约账户再给你的一个矿工，没有这么东西。这都是在改本地的数据结构。智能合约执行过程中，任何对状态的修改都是在改本地的这个数据结构。只有在合约执行完了，而且发布到区块链上之后，这个本地的修改才会变成外部可见的，才会变成区块链上的共识。

还有问题吗？

所以就是其他安全节点刚才也做了这个，他在全界面里面的状态是全额而。

对，就是这个你刚才说的是说我们有很多全节点，每个全节点都在本地做这个事情，执行的智能合约可能不完全一样。因为根据你收到的交易可能执行不同一样。如果某个全节点发布一个区块，我收到这个区块之后，我本地执行的就扔掉了完了这个区块的交易再执行一遍，更新我本地的三棵树。

这是不是浪费？

如果他要是没挖到。

你这说的是对的。如果我本来已经执行一遍了，然后我没有挖到矿，那个人发过来我又得执行一遍，我得执行两遍，多浪费。问题是你不这样还能怎么办？你那个区块里的交易，就你本地那个候选区块中的包含的交易，跟他发布的那个交易不一定完全一样。至少有一个肯定不一样，就是给出块奖励那个肯定不一样，他不会给你别的交易也不一定就一样。所以这个没有办法，都是得要重新执行一遍。

还有问题吗？回来。你说还你说就回到原来那个问题是应该先挖矿还是应该先执行，你说呢？先执行，有没有可能我先挖矿。

关于这个交易去执行过程中出了问题，跟你这个。

你说这个要先执行的原因是，如果先挖矿没有执行，没有执行的话，实际的执行过程中可能出现错误。要回滚。你都不知道，你就傻乎乎的发布到区块链上去了，到时候又改不了了。

我意思你的内容在区块上改了，但实际上并不是这样的。所。

会造成数据说我看我们还是退回来看一下这个数据结构。先问一下各位同学，以菜坊挖矿上怎么挖来着？其实也是尝试各种length，找到一个符合要求的。

那么计算哈希的时候要用到什么？要用到这个block
header的内容，对不对？Block ahead中的内容这三项是干嘛的来着？这个root
transaction hash Rept
hash是那三棵树的根。哈希值。所以应该先干嘛？你得先执行完这个区划中的所有交易，包括智能合约的交易。这样才能够更新这三棵树，这样才能知道这三个根哈希值，这样这个blohead的内容才能确定，然后你才能尝试各个。大家听明白了吗？

好，我们解决的第一个问题，就这个同学问的问题是应该先挖矿还是先执行？结论是得先执行，没有办法先挖矿。这样带来一个问题，假设我是一个矿工，我费了半天劲执行这些智能合约，消耗了我本地的好多资源，最后我挖矿没挖到怎么办？就比如说因为挖矿是竞争，对吧？很多矿工竞争记账权被别人抢先了，那我能得到啥补偿？我能得到汽油费吗？汽油费什么汽油费是没有的，因为汽油费只给获得记账权发布区块的矿工，那我能得到啥补偿？

但是有公司的协议，你就当一个出不去口。

有你说。

你说有构思的协议，你就当一个舒服区块好了。那你的意思是别人发布区块我不管他，我还继续挖，目的是为了成为一个舒服的区份，这个当然也是一种策略，不过一般不这么干。如果都像你说的这么干的话，这个共识机制就比较难达成共识了，等于你故意造成分叉。

其实你这么干对你其实没什么好处，你想想为什么？

下一步可能拉不到。就比如说假设按你说的，别人发布区块，你不管它，你沿着原来那个链继续挖，想成为一个舒服区块。然后挖出舒服区块之后你怎么办？你还是得切换到那个最长合法链上是吧？对，所以这个代价你没有省下来，那你干嘛不先切换到最长合法的链再继续挖呢？你是之前做的工作浪费了，但之前做的工作肯定也得浪费，你只要千万过去肯定都得浪费。而且挖矿是无记忆的，你之前挖了多少跟你后面挖矿的成功概率是没关系的。所以你还不如先去切换到那个最长合瓦链，然后再继续玩。

问题很有关，我最先结喝最早，其实根据这个并不证明我最先签就可以。概率。

不是，但是你不是我不是说最先切概率，因为你反正最后总得切，你挖出了舒服的区块也得切过去。所以你还不如把你继续挖舒服区块那个时间改成切换完之后，在新的那个链上挖，那样的话更好。大家听明白了吗？我想我们怎么说到这个地方来着，我说他能得到什么补偿？你就也得给他一点儿，不给一点意思不意思也不合适。

问题来了，谁给这个问的很好？以太坊中没有任何补偿。他得不到汽油费，也得不到任何补偿。不仅如此，他还要把别人发布里的那个区块里的交易在本地执行一遍。就是以太访谈规定要验证发布区块的正确性，每个全节点要独立验证。那怎么验证呢？就别人发布一个交易区块，你把那个区块的所有交易在本地执行完一遍，更新三棵树的内容，算出根哈希值，再跟他他发布的那个跟哈希值比较一下，看是不是一致。所有这些都是免费的，没有人给你补偿。

所以这种机制下，挖矿慢的矿工就特别吃亏。就本来汽油费的设置是什么目的？是对于矿工执行这些智能合约所消耗的资源的一种补偿。但是这种补偿只有挖到矿的矿工才能得到，其他的矿工等于是陪太子读书。有问题吗？

价格差距多大？

我们好像有一节课看过这个数据，就到目前为止，主要的incentive还是出块奖励，就那三个以太币汽油费只占很少一部分。

所以你说这个不是个大问题，反正汽酒费也没没多少，亏就亏一点。

相比于人家得一个那个。

你这个说的是有一定道理的。就在目前情况下，因为汽油费占的比例很小，所以这个问题也许不是很严重。

你又不是每一个区块或者说每个固定的。的一个，但是2万个区块。

这个说的也有道理，大家听明白了吗？就是初划奖励不是每个区块都能给你的。你可他那个例子说你挖2万个区块，挖到一次获得记账权，得到一次出块奖励，就2万个区块，每个区块都有一点小的稀有费。如果你都能得到汽油费的话，这2万个区块的汽油费加在一起可能就超过了出块奖率。

多大。

不他的意见是应该都应该分。

我的意思是说那个企。

你挖那么久，然后你也支撑了那么多，但是你一点收益都没有。

你说的是属于社会分配不公的一个现实情况，但实际上就是这样，你就是一点都没有。

那还不如不给汽。

油费，还不如不给汽油费就有问题。汽油费不是光是为了补偿矿工消耗的资源，也是为了遏制发起调用的那个账户。如果不给汽油费的话，那个账户可以瞎发。

对，其实一方面这个你要是。

但是问题不是你不给汽油费就更不公平了，那变成所有的狂风都得不到了。那我问下一个问题，会不会有的矿工跟同学们的想法一样，你不给我修油费，那我就不验证了。比如说我没有挖到矿，我挖了半天没挖到矿，你发布一个区块，按照协议我要验证一下你发布这个区块的正确性，我验证它能得啥好处，你又不给我汽油费，我验证它干嘛？我就认为你是正确的不就行了吗？我就接着挖，会不会有矿工想不开？

我们先说一下，如果出现这种情况会导致什么后果？不是一致性的问，也可以说是一致性最直接的后果是危害区块链的安全。区块链的安全是什么保证的？就是要求所有的全节点要独立验证发布的区块的合法性。这样少数有恶意的节点才没有办法篡改区块链上的内容。如果某个矿工想不通不给钱，我就不验证了。那么这样的风气蔓延开来，就会危及区块链的安全。会不会有这种情况？你说这种人毕竟是少数。

而且一旦他大假设大多数都是好的，因为他这么做的，然后他那个他肯定不是最强的。别人不认他，别人就接着。

别人为什么不认他？

因为别人要验。

别人要验跟他不一样没关，我就假设你是对的就行了，我七着八就行了。

那他那那几棵树。

这个说的才是对的，大家听明白了吗？如果他跳过验证这个步骤，他以后就没法再挖矿了。为什么？你验证的时候是要把这个区块的交易都执行一遍，更新本地的那三棵树。如果你不去验证的话，你本地三棵树的内容没有办法更新。以后你再发布区块，你怎么发布？你本地的这些状态就不对了。你算出的根哈希石发布出去之后，别人认为是错的，大家听明白了吗？这个没有办法跳过验证这个步骤。

为什么必须要执行才能更新状态？因为发布的区块里没有这三棵树的内容，只是块头里有个根哈希值。这三棵树的账户状态具体是什么余额，什么东西发布出来是没有的。大家记得我们大概很多节课以前讲状态树时候讲过，不能把状态树的整个状态都发布到区块链上。那太多了，而且很多是重复的，大部分状态是不改的。听明白了吗？所以不会跳过验证这一步骤，以太坊的安全还是有保证的。

还有一个办法，什么办法？自己抄过来把说抄过来就我自己不验证了，状态书怎么更新？问别人要，你把它告诉我。

干这个其实是属于类似于矿石的做法。矿石实际上就是很多矿工合在一起，矿工本身就不验证了。有一个矿石的pool
manager叫个全节点。我们以前课上讲过，全节点是要负责统一验证。然后大家这些矿工就相信那个全节点验证完之后的正确性。就全节点分配给矿工的时候，矿工看的只是一个具体的paddle的内容。这个pu是怎么来的？实际上是全节点通过跟着区块链更新来得到。

你们刚才还问过别的问题吗？没有，我来我问一个问题，就你刚来是有个类似的问题。发布到区块链上的交易是不是都是成功执行的？如果智能合约执行过程中出现了错误。要不要也发布到区块链上去？

要吗？没有必要，他都执行错了，非法交易我发布他干嘛？你说什么要扣掉汽油费？说这个同学说是对的，执行发生错误的交易也要发布到区块链上去，否则的话你汽油费扣不掉。你光是在本地的数据结构上把他的账户扣了汽油费是没用的，你拿不到钱。你得把它发布出去之后形成共识，扣掉的汽油费才能成为你账户上的钱。所以发布到区块链上的交易不一定都是成功执行的。

费了，他这个虽然让失败了。

对你要告诉大家为什么扣汽油费，而且别人也得验证一遍，也要把这个交易执行完一遍，看你扣的是不是对的。

那怎么知道一个交易是不是执行成功了呢？我们前面说过，三棵树每个交易执行完之后形成一个收据，这个是这个收据的内容。其中这个status这个域就是告诉你这个交易执行的情况是什么样。

到目前为止，还有什么别的问题吗？

那我再问一个问题。智能合约是不是支持多线程？

就现在大家知道吗？多核处理器很普遍，一个计算机有十几核，几十个核都是正常的。那么智能合约支不支持多核并行处理？

应该是可以的那里面有个写日志的那个操作是隐秘，因为这个他执行的状态应该。

如果这个系程崩了可能。

你这个想的有点多了，你的意思是说那个闲日志，隐秘的操作，这个日志要写下来。即使这个合约调用的时候合约崩掉了，这个日志单独用一个县程还能surviy把它给写下来。我们到目前为止没有讲任何对多线程的支识。

多线程有必要吗？多线程可以提高程序的运行效率，为什么没有必要？

如果一个对于简单的东西多显，就没有必要你上下文切换。这段时间可能一个人就。

你说因为智能合约都太简单了。

对，没看智能合约。

多线程上下文切换反而更浪费时间。首先现程的切换不属于contact test
switch那种东西，跟进程的康奈斯switch是不一样的。它内存什么都是共享的，每个县城自己拥有的状态是很少的。寄存器是自己共享，是自己独有的，但大多数都是属于。扫州的铁不支持多线程，它根本没有支持多线程的语句，原因是什么？

你说的不完全对，你说是因为出现县成同步的问题。

你说的有点关系，就是我们说以太坊是什么？是一个交易驱动的状态机。这个状态机必须是完全确定性的，就给另一个智能合约面对同一组输入，它产生的输出或者说转移到的下一个状态必须是完全确定。为什么要求这个？因为所有的全节点都得执行同一组操作，到达同一个状态要验证。如果状态不确定的话，你那三个书的根哈希值根本对不上，这必须完全确定才行。这个大家听明白了吗？

多线程的问题在于什么？多个核对内存访问顺序不同的话，执行结果有可能是不确定的。这个大家如果感兴趣的话，可以看一下我以前的一些论文。

这是我的home page。论文的话在这个paper mo下。

以前我们研究过的就是在多个环境下怎么样实现确定性重演，这是一个难度很大的课题。除了多线程之外，其他可能造成执行结果不确定的操作也都不支持。你们想到的还有什么？

有一个最直接、最简单的，会导致执行结果不确定的操作。

同时写，如果你没有多线程是确定性的。产生随机数。这个操作就是不确定的，而且这个操作必须得是不确定。如果不同的机器产生的随机数都一样，那不叫随机数了。所以以太坊中的智能合约没有办法产生真正意义下的随机属。他可以用一些伪随机数，不能是真的随机数，否则的话又会出现前面的问题。每个全节点执行完一遍，得到的结果都不一样。

大家听明白了吗？这个是智能科约可以获得的区块信息。为什么我要问刚才那个问题？智能合约的执行必须是确定性的这也就导致了智能合约不能像通用的编程语言那样，通过系统调用来得到一些这种system
core的一些信息，一些环境信息。因为每个全节点的执行环境不是完全一样的。所以它只有通过一些固定的一些变量的值，能够得到一些状态信息。这个表格就是智能合约能够得到的区块链的一些信息。

这个大概看一下，应该没有什么需要解释的。

下面这个是智能合约可以获得的调用的信息。像message点3的就是发起调用的人是谁？注意这个跟最后一个transaction
their origin交易的发起者是不一样的。

比如说我们有一个外部账户A。他调用了一个合约叫C1。这个合约中有一个函数F1，然后F1又调用了另外一个合约。C2里面的函数F2，那么对这个F2这个函数来说，message点sender是谁？是C一这个合约。因为当前这个message库调用是C一合约发起的。但是transaction点origin是什么？是A这个账户，因为整个交易最初的发起者是A这个账户。这个message的gas就是当前调用还剩下多少汽油费，这个决定了我还能做哪些操作。包括你要想再调用别的合约，前提是还有足够的汽油费剩下来。

这个message点data就是那个所谓叫数据，在里面写了调用哪个函数和这个函数的参数取值。Message点signature是这个message点data的前四个字节，就是函数标志符调用的是哪个函数。那就是当前区块的时间戳这个跟上一页这个。这个block点time
stamp是一个意思，就是智能合约里没有办法获得很精确的时践，只能获得跟当前区块信息的一些实践。大家看看还有问题吗？

这是我们说这个智能合学中地址类型，大家先看一下这些。

第一个是一个成员变量，剩下都是成员函数。这个成员变量就是这个账户的余额balance。注意这个U
int
256，这是这个成员变量的类型，不是函数调用，就不是说它有一个参数，这个参数是个优印，它259不是的。所以这成员变量本身的259。

这个是以V为单位的这是个很小的单位，所以这个账户余额看上去都很吓人，好像每个人都特别有钱，其实没多少钱。下面这些成员函数的话有一点要注意的，就是这些成员函数的语义跟我们直观上的理解不是很一样，跟第一个这个成员变量balance也不太一样。这个address点balance你们觉得是什么意思？

是address这个地址上的这个账户，它的余额对不对？Address点儿？Transfer,
比如说12345是什么意思呢？

感觉上是address这个账户往外转了1235个微，是不是这意思？对，这就说的。如果是这个意思的话，就问题在于他只有一个参数，他只有转账的金额，没有说转给谁。所以address
their
transfer是什么意思呢？并不是说dress这个账户往外转了多少钱，而是当前这个合约往这个address这个地址里转入多少钱。大家听明白了吗？这个address是转入的地址，不是转出的地址。转出的地址是哪个？

比如说这是个智能合约，C里面有个函数F它包含这条语句address their
transfer。意思是从C这个合约的账上往这个address地址里转入12345。这么多的钱大家听明白了吗？这比较诡异。这个扩咱们以前讲过对吧？咱们很多页ppt已前讲过，这扩调用函数，这个其实也是一样的语义。这个不是说就address点括，并不是说address这个合约账户发起一个调用，调哪个别的合约账户，而说当前这个合约发起一个调用，调的是address这个合约。

有问题吗？

这字太小，看不清是吗？

赚钱靠还有一个靠扣的，还有一个。

这就是delcate扩，我们上次不讲过了。Delcate扩的区别就是说它不需要切换到被调用的函数的环境中，就用当前合约的余额，当前合约的存储这些状态去进行运行就可以了。

那好，之前有同学是谁问的？是你问的还是他问的？比如说我向一个账户转账，说这个账户没有定义four
bu函数会引起错误，就会不会连锁回滚，这取决于你怎么转账的。

转账有3种方法。这三种形式都可以发送e区别是什么呢？就是这个transfer和sand这两个专门是为了转账的函数，区别在于transfer会导致连锁性回滚，就类似于你直接调用那个函数，直接调用的方法是一样的。失败时候抛出异常，而sand返回一个force，不会导致连锁式回滚。扩其实也是可以转账，就是扩点value，然后把这个扩点86，然后把这个转账金额送进去。后面这个你如果不用调用函数可以是空的。

区别在于send和transfer是专门用于转账的。括的话本意是发动函数调用，但是也可以用来转账。这个也不会引起连锁式回滚，失败时候返回force。

另外一个区别是什么？这两个在发起调用的时候只给了一点儿的汽油，就汽油是2300个单位，这是非常少的。收到这个转账的这个合约，基本上干不了别的事儿，也就写一个log就行了，别事都干不了。而这个扩这个是把当前这个调用剩下的所有的汽油都发过去。比如说这个扩所在的这个合约，它本身被调用的时候可能还剩8000个汽油。然后他去调别的合约的时候，如果是用扩这种方法去转账，就把剩多少汽油都发过去了，这是另外一个区别。

如果考完了，我还要我考完之后我想。

就没有用完会退回来的。你不一定不是发给你的，你不一定都用完。

那就是他立马得。

什么叫执行完毕就要立马撤回？

我这个靠完后执行完之后，下面立马要。

就你扩函数，括别人另外一个合约中的函数，那个函数执行什么你是控制不了的，他可能再去调别的合约。所以什么叫做马上就退回来？

他的就是我靠完了之后，我下面还有我的贷款。对，执行我的操作，我把汽油费全都发过去了。

那他花多少你控制不了，他可能会他拿到这个汽油费之后，可能调用很多别的合约。然后都执行完之后，还有什么汽油费返回来之后，你还可以接着运行。

还有问题吗？好，我们回到我们一开始讲的这个例子，这个拍卖的例子。

我们说一下这个拍卖的规则，这个拍卖有一个受益人就这个by比如说你有一个古董叫拍卖，那么这个受益人就是你。这个ocean
end是整个拍卖的结束时间highest
be是最高出价的人。这个拍卖的规则是这样的。在拍卖结束之前，每个人都可以去出价，可以去竞拍。竞拍的时候，为了保证诚信，你要把你竞拍的价格的相应的以太币发过去。比如说你出价出100个以太币，那么你竞拍的时候用那个B的函数。竞拍的时候B的函数在那没写，你就把这100个以太币要发到这个智能合约里，而且会锁在这里面，直到这个拍卖结束。

就这个拍卖的规则不允许中途退出。你说我去竞拍，我发100个亿台币，过一会儿我后悔了，先把钱要回来。这个不行，大家听明白了吗？然后拍卖结束的时候，出价最高的那个人就这个highs。他投出去的钱会给这个受益人，这个beneficiary。当然了，你也应该把那个古董想办法给最高出价的人。

那么其他没有竞拍成功的人怎么办呢？可以把当初投进去的钱再取回来，大家听明白了吗？就这么一个过程。

竞拍是可以多次出价的。比如说我出了个价钱100个亿台币，另外一个人出个价钱110个亿台币，然后我再出个价钱120个亿台币，这个时候我只要补差价就行了，就把我这次的出价跟上次出价的差额发到这个智能合约里。我上次投标的时候已经发了100个亿台币，所以这次只要再发20个亿台币就行了。出价要有效的话，必须比最高出价还要高。就比如说当前的最高出价是100个亿台币，我去竞拍我投80个亿台币，那这是无效的这等于是非法的拍卖。

然后这就是我们说的那两个事件。这个construct会记录一下这个受益人是谁，结束时间是什么时候。这个构造函数在合约创建的时候把这两个就记下来了。

这个是拍卖的用的两个函数。左边这个B的函数是竞拍的时候用的。你要竞拍，你就发起一个交易，调用这个拍卖合约中的这个B的函数。这个B的函数有一个奇怪的地方，它没有参数。感觉上你竞拍的时候，难道你不需要告诉对方你出了价格是多少吗？

对他在哪个地方写的呢？Message点value，这是发起这个调用的时候送转让转过去的以太币书，以V为单位的转账金额。所以这个逻辑是什么？首先查一下当前这个拍卖还没有结束，如果拍卖结束了你还出价，那么会抛出异常。然后查一下你上次的出价，加上当前这个调用的时候发过去的以太币大于这个最高的出价。如果你以前没有出嫁过会怎么样？

这个B字是个哈希表，那么手罗地体中哈希表的特点是，如果你要查询的那个键值不存在，那么它返回默认值就是零。所以如果没有出过价，第一部分就是零。第一次拍卖的时候，把这个拍卖者的信息放到B的数组里。这个原因我们就是一开始讲的扫得里的哈希表不支持便利。你要遍利哈希表的话，你得保存一下它包含哪些元素，然后的话记录一下新的最高出价人是谁，写一些日志之类的。

右边这个是拍卖结束之后的合约，拍卖结束之后的函数。首先查一下拍卖是不是已经结束了。如果拍卖还没有结束，有人调用这个函数就是非法的，会抛出异常。然后这个是判断一下这个函数是不是已经被调过了，如果已经被调过就不用再调一遍。

首先把这个金额给白年非数人，这就是我们前面那个ppt讲的，大家理解一下这是什么意思。Beneficial
transfer是当前这个合约，把后面这个金额给百尼富士瑞转过去。就最高出价人的钱是给受益人了，然后剩下那些没有竞拍成功的怎么办？用一个循环，对于没有成功的人，把这个金额退回给B得。然后标注一下这个函数已经执行完了，写一个log。

有什么问题吗？

你说安倍的应该是个全局变量。

就是标志当前这个。

标志当前竞盘是否结束。什么叫权利变量？你说成员变量是么？你是想指成员变量吗？这就是成员变量安这。

你说什么问题？就是这个拍卖他来肯定持续时间不会死短。然后把它放在链儿上，它这个具体。

就是他那个竞价的那些东西，他要。

你的问题是说这个拍卖时间不会很短，它要持续挺久的。那么净拍售候这些出价什么的记录在哪个地方不？我们可能还需要理清一下智能合约是怎么工作的。我前面是不是讲的太快了？就你写完一个智能合约时候，比如你写这个拍卖程序，然后你要先把它发布到区块链上，发布怎么发布来着？

往那个零地址。

往那个零那个地址发一笔转账交易，转账的金额是0，然后把这个智能合约的代码放到data域里面，然后矿这汽油费是要交的，就转账金额是0，汽油费是要造给的。然后矿工把这个智能合约发布到区块链上之后，会返回给你一个个合约的地址，然后这个合约就在区块链上了，所有人都可以调用它。所以回答你那个问题，你的问题是什么来着？就是你每次竞拍它存在哪儿？智能合约本身有一个合约账户，里面有它的状态信息。这些都是在它的存储都是在一个mt里存着的这些东西。

那他这个用不着矿工来执行。

吗？要矿工执行，你拍卖的时候怎么拍卖，只是这个流程还是没有搞明白，拍卖的时候怎么拍。拍卖的时候是你这个比如说你的外部账户，你要拍卖，你要发起一个交易。这个交易要调用这个B的函数，然后这个交易调用B的函数得矿工写到区块链里。对，每一次每任何一个人出价参与这个竞拍，都要用这个B的函数的操作，都需要发布到区块链里。你还得转账转过去，对不对？

又写。

转账，当然得写在区块链里了。你不能自己闹着玩，你不发布出去的话，别人不认账的。

我是不是还得搞这个合约，得搞一个这种公开的这种信息类型这种东西。但这种东西应该。

同学们可能是不是我没讲清楚怎么你们还没有这个概念。你说要我你要搞一个竞拍，你得先去申请一个合约账户，得搞一个什么东西。不是你搞一竞拍，你就写一个程序，随一个所在地的程序。然后你发布一个交易，把这个合约放在网上，然后别人怎么知道你这个合约。那你得线下宣传，你用别的方法宣传，区块链不负责给你做这个宣传。就像你的我们以前讲比特币的时候讲过，你的比特币地址别人怎么能知道你自己去宣传。咱们这门课其实可以搞一个比特币机制，接受大家的捐款，这个你自己得宣传。然后你这个合约地址知叫之有别人去竞拍，就都是在区块链上通过转账交易来执行的。

没有问题了吗？别的同学也没有问题了吗？主要是快要下课，要到吃饭时间了，我们拖堂一会儿行不行？拖堂1个小时。这个我说是有问题的，智能合约这么写是有问题的。

你到底想说什么问题？那就是。

写智能合约一定要小心，因为区块链是不可篡改的。说的好听点叫不可篡改，说的不好听点就是你没法改bug，你有bug没法改。这有什么问题？

你知道了。

是不是拍卖结束，就是他得按自己的那个。

拍卖结束，这安的放的位置不对。

为什么不被，是不是应该放在那个？好几个同时同时调用啊。他前两。

你说这个and的这个成员变量赋值成处应该在转账之前复值成处。否则的话可能有多个参与拍卖的人都调用这个option，and然后把这个转账都执行一遍。

对。

这个其实你说了一个很重要的问题，就是凹胜案的这个函数必须要某个人调用才能执行。这个也是所的这些语言跟其他编程语言不同的一个地方，就是没有办法把它设置成拍卖结束了自动执行auand，你可能是拍卖的受益人beneficiary去调用ocean，and也可能是某一个参与竞拍没有成功的人去调用，但总之得有一个人去调用。但是你说的那种情况不是一个问题，就如果两个人都去调用ocean，and矿工在执行的时候把第一个调用执行完了。然后第二个调用再执行就执行不了了。因为第一个执行完之后，那就是处了没有并发执行，你还是想着多线程并发执行，没有并发执行。

么我看答案。假设有一个人通过这样一个合约账户参与竞拍，会有什么结果？

这个合约实际上就一个函数，对吧？Hacker
b的这个函数在干嘛？它的参数就是那个拍卖合约的地址，然后他把它转成这个拍卖合约的一个实例，然后调用拍卖合约中的B的函数，把这个钱发送过去。

这个实际上应该怎么用？因为这是个合约账户，合约账户不能自己发起交易。所以实际上得有一个黑客从他自己的一个外部账户发起一个交易，调用这个合约账户的这个ha克b的函数。然后这个函数再去调用拍卖合约中的B的函数。把他自己收到的这个转过来的钱，这个黑客外部账户转过来的钱，再转给这个拍卖合约中的B的函数，就参与拍卖了。

有问题吗？好像还是没有问题。还是没有问题是吗？我们看一下我们上一页的函数，auction
n。这个合约参与拍卖没有问题，最后拍卖结束退款的时候会有什么问题？

这个红框里通过这个循环退款，退到这个合约账户上的钱会出现什么情况？

对，退到这个智场这个黑客合约上的钱会有什么情况？

但是问题在于一个合约。

不黑客外部账户对这个拍卖合约来说是不可见的。拍卖合约能看到的只是这个黑客的合约。

他这个想逻辑应该是这个合约账户去降这个合约账户。但是现在这个合约账户他根本不知道他有什么函数，所以就会掉到那个风外的里面去。

不是说他不知道他有什么函数，这个转账的时候没有调用任何函数。那么当一个合约账户收到转账没有调用任何函数的时候，应该调用for
bu函数。而这个合约没有定义for
bu函数，所以会怎么样？会调用失败对吧？而调用失败会抛出异常。这个transfer函数是什么意思？它会引起连锁式的回滚。所以导致这个转账操作是失败了，收不到钱了，对不对？

那对他有什么好处呢？我先问一个问题，谁收不到钱？

只要最高价的人不需要收钱，不是，这是最高价值。人是一个。

收益人。

对，其他所有的就是没有竞拍到这个人的人。

没有竞拍到这个人的人。

没有竞拍到这个。

你俩说的不一样，就我们说更具体一点。比如说有20个人参与竞拍了，这个黑客合约排在第十个，benefici这个最高出价应该给Ben年fi是最高出价者排在第16个。最后是有哪些能够收到钱，哪些收不到钱？

听明白我问什么了吗？

你说的回滚到哪儿？

按你的这个函数就可能会。

拍卖结束了，奥案的这个时间点是过了。比如说先说这个收益人能不能收到钱，一开始执行的时候先把这个钱转给这个收益人。你说他会收到。之后回滚又收不到了，你们俩的观点不一样。

不是要稳。

对，回款是候推回到执行之前的状态，所以前面那个转账到底是收到还是收不到？

他到底退到哪去是啥意思？

为什么我要问这个问题？其实关键在于这个转账操作是怎么转的。是说我银行上有一笔钱我转给你我按照这个顺序，20个人转转到第十个转账出错了，是这样吗？

把钱交易一样这样把钱交易进去。所以其实他写了一笔一笔的交易转给。

你说是这里转账，不是银行转账，是发起交易。他实际上写一笔笔的交易要转给谁转让。

转给谁下，把这个交易再打去块。

然后再把这个交易打到区块链上去。

你要立场坚定，你原来说的是对的，现在你要动摇。那这个过程是怎么样的？这个转账实际上是在干嘛？是你这个矿工或者说全节点执行到这个百transfer的时候，把相应账户的余额进行了调整。

大家听明白了吗？所有的扫灾类铁的语句，就智能合约的执行过程中的任何语句，对状态的修改，改的都是本地的状态，都是改的本地的数据结构。所以这个循环当中，不论是排在这个黑客合约前面，还是排在到后面，都是在改本地数据结构。只不过排在后面的这个逼得根本没有机会来得及执行，然后整个都回滚了。

听明白了吗？就好像这个智能合约从来没有被执行过。所以排在前面的这些转账并没有执行，也不像你说的是形成一条流交易。它不形成交易就是改本地的数据结构。然后如果都顺利执行完了，发布出去之后，别的矿工也把这个action案从头到尾执行一遍，也改他本地的数据结构，跟你的能对得上，这就叫形成共识了。而不是说没有一个转账交易的语句是产生一个新的交易，写到区块链上，不是这样的。所以谁收不到钱？都收不到钱，没有任何人能收到钱。

办理公司的人。好就是。

发起这个攻击的人的好处，有可能这个人是故意捣乱，写这样一个程序，然后大家都拿不到钱。也可能是这个人不懂，他就忘了写佛败的函数了。也有可能。

那出现这种情况怎么办呢？怎么办？比如说你发布一个拍卖的合约到区块链上，然后吸引大家很多人来拍卖。拍卖完之后发现有这样一个问题，这个黑客合约你怎么办？

这个拍卖失败的最后的结果就是说所有。

不是你的问题是回滚是啥意思？是不是说就好像这个拍卖的事情在网上从来没有发生过，如果这样的话就好了。

现在的问题是什么？你已经把钱投进去了，锁在里面了，你怎么把它取出来的问题。

怎么办？出现这种情况。

一直回滚到还没有往里面打钱的时候，怎么回滚到那个时候？

所以同学们的回答是对的，没有办法出现这种情况，没有办法。大家听说过一种说法吗？

Code的一落势能合约的规则是由代码逻辑决定的，而代码一旦发布到区块链上就改不了了。这所谓的叫区块链的不可篡改性。这样的好处是没有人能够篡改规则，这样的坏处是规则中有漏洞，你也改不了了。这个大家要注意，智能合约如果设计的不好的话，有可能把收到的以太币永久的锁起来，谁也取不出来。

以前还有那种用智能合约锁仓的。就比如说我们要开发一个新的加密货币，然后，就像前面说那个prman先预留一部分币给这个开发者，后，这些币我们都打到一个智能合约账户锁昌三年，三年以后这些币才能卖。这样做主要是为了大家一开始的时候能集中精力开发这些加密货币。这个挺好的对吧？

智能合约锁仓是个常用的操作。万一你要是写的时候写错了，多写一个零变成30年，这些币就会锁上30年，没有办法。这个有点像什么？像那种不可撤销的信托，这个叫做。

Irrevocable trust,
大家听说过这个吗？美国有一些有钱人用这种信托来达到财产保护或者是减税的目的，这个就是一个法律上的合同。如果制定这种不可撤销的信托的时候，法律条款的设计有问题，也可能会导致存进去的钱取不出来。所以在你发布一个智能合约之前，一定要测试测试再测试。你可以在专门的那种test测试的网上用假的以太币做测试，确认完全没有问题的情况下再去发布。

我再问一个问题，我能不能在这个智能合约里留一个后门用来修复bug？

比如说给这个合约的创建者超级用户的权利，比如我们前面这个。

这个构造函数里我们加一个域叫on了。

记录一下这个owner是谁。然后对这个owner的地址允许他做一些类似于系统管理员的操作。比如可以任意转账，把钱转给哪个地址都行。那样的话如果出现这种。像这种bug，这个超级管理员就可以发挥作用，把锁进去的钱给转出来了。因为反正对他没有限制，他转给谁都行，这样行不行？

出现卷款跑路的情况。

这样有可能出现卷款跑路的情况。就这样做的前提是所有人都要信任这个系统管理员，这个超级用户。这个跟去中心化的理念是背道而驰的，也是绝大多数区块链的用户不能接受的。好，回到我们这个程序，那怎么办呢？难道不拍卖了吗？

第二个版本我们把前面那个option
and拆成两个函数，左边的是尾字座，右边的是pay to
beneficiary。大家先看一下这两个函数。

这个萎弱是什么意思呢？我们在不用循环了，我们在这里就不用循环了。每个竞拍没有成功的人，自己调用尾子做函数，把那份钱取回来。首先判断一下这个拍卖是不是结束了，然后看一看调用的这个人是不是最高出价者。如果是的话，不能把钱给他，因为要留着给那个拍卖的百iciary，然后看一下这个人账户的余额是不是正的。这个amount是什么？就他的账户余额。然后，message点3的就是把这个账户余额转给这个message点3的就发起调用的这个人，然后把他的账户余额清成0，免得他下次再来取一次钱。就是韦得住to
benefici是说把最高出价给这个受益人，也是判断一下拍卖已经结束了，最高出价的金额大于0，然后下面就把它转过去。

这样可以了吗？

有什么问题。

是不是投标的，比如说。

大家听明白了吗？

他说的是对的，这有什么问题？重物攻击如果有一个黑客写这样一个程序会怎么样？

这个hacker b就跟我们前面那个ha客合约里的hacker
b是一样的。通过调用拍卖合约的B的函数参与竞拍，海克韦子座就在拍卖结束的时候，调要用尾子座函数把钱取回来，这两个看上去好像都没什么问题，问题在哪儿？这个for
back函数，这个for函数在干一个什么事情？

又把钱取了一遍，对吧？这是我们刚才显示的纬座函数。

Hack
draw调用拍卖合约的伪draw函数的时候，执行到这个地方会向这个黑客合约转账，对吧？这个message点3的就是这个黑客的合约，把他当初出价的金额转给他，而这个合约在干嘛？他又调用了这个拍卖函数的纬度作函数，又去曲线这里的message点sender就是这个拍卖合约。因为是拍卖合约，把这个钱转给这个合约。然后这个拍卖合约在干嘛呢？又执行人员执行到这里面，再给他转一次钱。

注意这个清零的操作，把这个黑客合约账户清零的操作，只有在这个转账交易完成之后才会进行。而前面这个转账的语句已经陷入到了跟黑客合约之间的递归调用当中，根本执行不到下面这个清零的操作。所以最后的结果就是这个黑客一开始出价的时候给出一个价格，拍卖结束之后就按照这个价格不停的从这个拍卖合约中去取钱。第一次娶的是他自己的出嫁，后面娶的就是别人的墙。

那这个地归重复取钱，持续到什么时候会结束？

有三种情况，一个是这个拍卖合约上的余额不够了，不足以在支持这样一个转账的语据。第二种情况是汽油费不够了，因为每次递归调用还是消耗汽油费的，到最后没有足够的汽油剩下来了。第三种情况，调用战一出了。所以在这地方判断一下这个黑客合约的for
back函数，判断一下这个拍卖合约的余额还足以支持转账汽油。当前调用的剩余汽油message点gas还有6000个单位以上调用战的深度不超过500，那么就再发起一轮攻击。

那怎么办呢？这个该怎么修改？一个最简单的是先清零再转正。其实就是我们右边的这种写法，右边陪图beneficiary写法是正确的。在这个地方已经把highs
bi的账户余额清成零了。就在币字里面这哈希表的余额清成零了，然后再转账，转账如果不成功的话，再把余额恢复。

这个实际上是对于可能跟其他合约发生交互的情况的一种经典的编程模式。就先要判断条件，然后改变条件，最后再跟别的合约发生交互。在区块链上任何未知的合约都可能是有恶意的。所以每次你向对方转账或者是调用对方的某个函数的时候，都要提醒一下自己，这个合约这个函数有可能反过来调用你当前的这个合约，并且修改状态。Better
safe than sorry, 小心一点总是好的。除了这个修改方式之外，还有一种办法。

就是不要用扩点value的方法转账。我们对比一下修改前后的两段代码。区别就是绿框这个部分。首先我们把这个清零的位置提前了，先清零再转正。而且。我们转账的时候用的是sin
m用transfer也可以，就send和transfer。我们说有一个共同的特点是什么？

转账的时候发送过去的汽油费只有2300个单位。这个不足以让接收的那个合约再发起一个新的调用，只够写一个log而已。

大家有问题吗？

网上拍卖不容易吧。

还有问题吗？没有问题，这个程序就正确了。大家还有问题吗？就刚才那个同学问的那个问题，就像第一个那种错误，就我们说有一个黑客合约没有写for
bu函数，大概是在这个位置。

就是这个如果这个不是一个黑客合约，就是一个普通的账户，他忘了写附带函数怎么办？也没有办法，就算这个账户愿意改，也是改不了的。他没有办法再把for败函数补上了，因为这个合约发布到区块链上去了。你可以再创建一个新的合约，但是这个合约已经参与了这个拍卖了，已经被记录在这个循环里面了也没有办法。

今天我们这个课讲的内容比较多，也拖堂了不少时间，大家回去好好消化吸收一下。我们讲了智能合约中可能出现安全漏洞的一些例子。这些安全漏洞在实际当中是不是真的会发生呢？我们下节课讲一些实际的例子，好吧，就上到这儿。
