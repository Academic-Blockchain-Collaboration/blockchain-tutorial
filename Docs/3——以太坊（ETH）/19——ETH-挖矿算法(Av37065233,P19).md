**19.19-ETH-挖矿算法(Av37065233,P19)**

今天我们讲以太坊中的挖矿算法，对于基于工作量证明的区块链系统来说，挖矿是保障区块链安全的一个重要手段。所以我们有时候说。

Is secured. By money.

比特币当中用的挖矿算法，总的来说是比较成功的，经受了时间的检验。到目前为止，没有人发现里面有什么大的漏洞。大家听说过八个帮体吗？

有谁听说过这个词吗？

邦铁这个词的意思是赏金的意思，就我们看有的美国电影里又叫。当天、hunter.
赏金猎人专门去抓那些政府悬赏捉拿的逃犯。这个bug帮体的意思是说，有的公司悬赏来找软件中的漏洞。如果你能够找到他们软件中的什么安全漏洞，就可以得到一笔赏金，这叫bug帮停。

比特币的挖矿算法是一个天然的bug帮铁。如果你能找到里面的漏洞或者是某一个挖矿的捷径，就所谓叫shortcut就能取得很大的利益。但是到目前为止，还没有人能够发现有什么捷径可走。所以说比特币的这个挖矿算法，总的来说是比较成功的，是经受住时间检验。

但是比特币的挖矿算法也有一些值得改进的地方。其中有一个饱受争议的问题就是挖矿设备的专业化。用普通的计算机挖不到矿，只能用专门的设备专用的a芯片来挖矿。很多人认为这种做法与去中心化的理念是背道而驰的，也跟比特币的设计初衷是相违背的。大家如果去看一下中本聪最早的比特币论文，它里面提出了一个说法叫做。

One cpu, one mode.
理想状况下，应该让普通的老百姓也能够参与挖矿的过程，就用自己家里的桌面机、笔记本电脑甚至手机来挖矿，这样也更安全。因为算力分散之后，有恶意的攻击者想要聚集到51%的算力发动攻击，这个难度就会大得多。所以比特币之后出现的很多加密货币，包括以太坊。设计manpadle的时候，一个目标就是要做到asic
resistance。

那么怎么才能够设计出一个对a芯片不友好的尼帕O呢？一个常用的做法就是增加这个pado对内存访问的需求，也就是所谓的memory
hard manding puzzdle。

为什么要这么做呢？A四个芯片相对于普通计算机来言，它的主要优势是什么？主要优势是算力强，就计算能力很强，但是在内存访问的性能上并没有那么大的优势。就比如说你用同样的价格，你买一个A矿机跟买一个普通的计算机。这个a个矿机的计算能力可能是普通计算机的几千倍。因为它里面有很多核能进行大量的并行计算，但是内存访问上面的性能差距并没有这么大，远远没有这么大。所以如果我们能设计出一个对内存要求很高的puaddle，那么就能够起到遏制a芯片的作用。那怎么设计呢？这方面一个早期的例子就是莱特比。

这个莱特币曾经是市值仅次于比特币的第二大加密货币，他用的这个puaddle是基于ascript。

这个是一个对内存要求很高的哈希函数，以前是用于计算机安全领域的，跟密码相关的。它的具体设计思想是说我开设一个很大的宿主。比如说我们画在哪儿呢？画这儿。

按照顺序填充一些尾随激素。就比如说第一个数，我有一个种子节点有个se的值，把这个C的值通过一些运算算出一个数来填在第一个位置，然后后面每个位置都是前一个位置的值取哈希得到的这为什么叫尾随机数？因为你哈希取完之后算出来的值是什么你也不知道，看上去就是乱七八糟的数，就好像是随机数一样。但实际上我们不可能真的用随机数，真的用水泥数字化没法验证，就这样填充完。

这个数主填充的一个特点是里面的取值是有前后依赖关系的。是从第一个数依次算出来，然后需要求解这个pdo的时候，按照尾随机的顺序从这个数主当中读取一些数，每次读取的位置也是跟前一个数是相关的。就比如说我们要解趴dle了，我们一开始读取这个位置的数，就A这个位置的数。把A这个位置的数值读出，读出来之后，根据它的取值进行一些运算，算出下一次要读取的位置。比如说是B这个位置。然后把B这个位置的数读出来，再经过一些运算得到下一个读取的位置。比如说C这个位置。这个也是一种伪随机的顺序，因为它经过哈希运算之后，得到下一个读取的位置。

这样做有什么好处呢？如果这个树主开的足够大的话，那么对于挖矿的矿工来说就是memory
hard。因为如果你不保存这个数主，那么挖矿的计算复杂度会大幅度上升。大家听明白了吗？就比如说需要读取这里面这些数的时候，你没有保存这个数组，那你怎么办？比如说求解趴到的时候，一开始需要读取A这个位置的数，你没有这个数组的话，你还得从第一个数依次算算出A这个数的值，然后要读取第二个未知数，你这些没有存起来，那么再算一遍，算到B这个位置的值，然后下面是C也一样，要算到C这个位置时，这个计算复杂度会大幅度上升。所以要想高效的挖矿，这个内存区域是需要保存的。

当然了，有的矿工可能保存一部分内存区域的内容。比如说这个数股当中只保留奇数位置的元素，偶数位置的元素就不存了，这样数主可以少一半，那你用到偶数位置怎么办呢？你根据另外一半去算一下，就是它计算复杂度会提高一点，但是它内存可以减少一半，这个有时候管它叫做。写哪time。Memory.
Cheda.

大家听明白这个设计了吗？这个设计你们觉得怎么样？

又是什么想法吗？

大家听明白这怎么设计论吗？

不能让他一直只使用cpu进行计算，而且就是要。对，就是你说的基本上是对的。就是核心思想是什么？不能像比特币那样主要进行哈希运算。比特币其实也不是取一次哈希，他取了两次哈希，但这个不够，要增加它的运算过程中对内存访问的需求。

就是我们要设计一个对AC的芯片不友好的，让普通计算机能参与的那怎么办呢？就按你设计的这个任务，更像是一个普通计算机干的事情，而不像是一个挖矿专用的ac
c芯片怪的事情。普通计算机内存是很大的，然后的话当然普算计算机还有别的特性，它还有一些很大的硬盘什么的。所以就要利用它这个特性设计这个pa的资源对资源的需求，特别像是普通计算机对资源的配备比例。所以大家觉得这个帕豆挺好。

是吗？

这个pdle好的地方是对矿工来说，挖矿的时候是memory
hard。坏的地方是什么对清洁点来说也是慢门。我们前面讲过我们设计paddle的时候的一个原则是什么？

要求解趴dle很难，但是求解完之后要验证那个pdle应该很容易才对。这个问题就在于验证这个pudle需要的内存区域跟求解这个pudle需要的区域几乎是一样大的。你清洁点要验证的时候，你也得保存这个数，主要不然的话，它计算复杂度也是大幅度提高。就对于s
cript的早期的计算机安全领域，这个密码方面的话，这个不是个问题。它没有清节点验证的问题，但对于我们这个厂景来说是不行的。

这样造成一个什么结果呢？就是埋特币真正使用的时候，这个内存区域不敢设置的太大。比如说你设一个一G的数主，这对于计算机来说问题是不大的。一G的内存问题不大，但是如果是一个手机上的app，一季的内存可能就太大了。因为这个原因，实际莱特币在使用的时候，这个数主只有。128K。这个是非常小的，连一兆都不到，就一百多K。

就是为了照顾清洁点，那么最后的效果怎么样呢？当初莱特币在发行的时候，目标不仅仅是A
C resistance，而且还是GP U
resistance。就是你挖矿最好是连gpo都不要用，就大家都用普通的cpu挖矿就行了。结果怎么样呢？后来就出现了用制皮油挖矿，再后来就出现了ac的芯片拉矿。实践证明，莱特币要求的这个128K的内存不足以对ac芯片的生产和设计带来实质性的障碍。所以从这一点来说，莱特币这个设计目标是没有达到。但是他早期宣传的这个设计目标，对于解决奈特币的能启动问题是很有帮助的。

任何一个加密货币都存在能启动的问题。包括比特币一开始的时候没有人知道你这个加密货币，你就发现一个货币也没有人理你那怎么办呢？没有人参与，这是一个问题。而且对于基于工作量证明的加密货币来说，挖矿的人太少是不安全的，因为发动恶意攻击的难度就太低了。比特币的早期也是不安全的，一开始的时候只有中本聪一个人在用，后来变成少数几个人在挖矿。那个时候如果你想对比特币系统发动恶意攻击是很容易的。

那么比特币是怎么解决这个能启动的问题呢？现在谁也说不清楚了，但总的来说是一个循环迭代的过程。中本聪宣传的多了，对比特币感兴趣的人就多了，然后参与挖矿的人就多了，比特币就变得更安全了，那么它的价值也就提高了。对比特币感兴趣的人就更多了，挖矿的人也就更多了，然后比特币变得更安全了，价值就更进一步提高了，就形成一个良性循环。

莱特币虽然没有达到当初的设计目标，但是他早期的这种宣传，这种更民主，让更多人参与的这个理念，对于聚集人气来说是很重要的。所以莱特币一直到现在仍然是一个比较主流的加密货币。除了这个manpudle之外，埋特币跟比特币的另外一个区别是莱特币的初快速度是比特币的四倍，它的初快间隔是两分半而不是十分钟。除此之外这两种加密货币基本上是一样的。

以太坊也是用一种memory
hard的manpadle，但是在设计上跟莱特币有很大的不同。以太坊用的是两个数据集，一大一小小的是一个16兆的cache。

大的数据集是一个一致的data
set。这个叫做dag。这一G的数据集是从这16兆的cache生成出来的。为什么要设计成一大一小的两个数据集？就是为了便于验证清洁点，只要保存着16兆的ch就行了。只有需要挖矿的这个矿工才需要保存这一致的大数据集。

他的基本思想是这样的，这个小的数据，这个cache的生成方式跟我们前面讲的这个数主的生成方式是比较类似的。首先从一个种子节点经过一些运算，算出数主的第一个元素，依次取哈希，第一个元素取哈希得到第二个元素，第二元素取哈希德的第三个元素。这样把这个数主从前往后填充这些伪随机素就得到一个cash。然后下面跟莱特币就不一样了，莱特币是直接从这个数股当中按照尾随机的顺序读取一些数，然后进行运算。以太坊是要先生成一个更大的输主。

我们这地方没有按比例化。

这个大数主应该比下面这个小数主要大得多。这个图上看好像就大一点，因这黑板画不下了。而且有一点就是这个小的cache跟这个大的data
set都是定期增长的，每隔一段时间它这个大小要增大。因为计算机的内存容量也是定期增长的。比如说这个大的data
set现在已经涨到2.5G了，就已经不是一个G了。

那个大的数据集怎么生成的呢？它的每个元素都是从这个小的cache里按照尾随机的顺序读取一些元素。方法跟刚才讲的莱特币里面求解part的过程是类似的。比如说第一是它实际上是说第一次比如说读取A这个位置的元素，读取完之后，对当前的哈希值进行一些更新迭代，算出下一个要读取的位置。比如说B这个位置，然后把B位置的数再进行一些哈希值的更新，算出C这个位置。那么从这个c里面这么来回读，一共读256次，读256个数，最后算出来一个数放做这个大的data
set的第一个元素。然后第二个元素也是一样的，就这个data
set的每个元素都是从这个cache里面按照尾随机的顺序读取256个数。然后不断的进行迭代更新，最后得到一个哈希值存在在里面。

然后求解这个padle的时候，用的是这个大数据集中的数。这个cash
ache是不用的，按照伪随机的顺序从这个大的数据集中读取128个数。一开始的时候，根据这个区块的块头。包括你们这个length值。

算出一个初始的哈希，根据这个哈希映射到这个大数据集中的某个位置。比如说这个位置把这个数读取出来。进行一些运算，算出下一个要读取的位置，比如说是这个位置再把这个数读取出来。它这里有一个什么区别呢？它每次读取的时候，除了计算出这个位置的元素之外，要把它相邻的一个元素也要读取出来。所以这个例子当中是每次读取的时候是读取两个相邻的元素。这样循环64次，64轮循环，每次读两个元素，所以一共是128个数。大家听明白了吗？

最后算出一个哈希值来跟我们挖矿难度的目标阈值比较一下，是不是符合难度要求。如果不是的话，把这个block
head的length再替换一下，换另外一个n然后重新。因为你n换之后，你第一次算出的那个哈希值就变了。

然后又重复的一个过程，根据这个哈希值找到数组中的元素，读取两个相邻的元素，然后反复循环64次，再得到一个哈希值，然后再去比较。这个high
ni的过程大家有什么问题吗？这个听上去是比较抽象，所以这部分内容我们准备一个ppt我们先有没有什么还never需要回答的问题。

好，下面我们可以看一下这个ppt这个PP用的代码是我们自己写的一个伪代码。我们没有直接用以太坊当中的源代码，我们这个伪代码省略了源代码中的一些实现的细节，这样更有利于同学们直接理解。对于我们这节课这个教学目的来说，这个伪代码是已经足够了，好吧。

我们来看一下这个伪代码。第一步，首先生成16兆的cache，cache中每个元素都是64个字节的哈希值，生成的方法与乃特比类似。第一个元素是种子的哈希，就是这个参数C的哈希，后面每个元素是前一个的哈西。这个c始的内容每隔3万个区块会变化一次，这个C的每隔3万个区块会发生变化，然后重新生成cache中的内容。同时cache的容量要增加原始大小的128分之1，也就是16兆的128分之1等于128K。

第二步是从这个cache生成一致的大数据集。我们先看一下这一页上calculate
data set
item这个函数，这个函数的功能是通过cache来生成大数据集中的第二个元素。基本思想是按照伪随机的顺序读取c中的256个数，每次读取的位置是由上一个数的数值经过计算得到的，这里用的两个函数get
int from
item和make。Item是我们自己定义的，源代码中是没有的。我们把源代码中一些相关的内容总结成了这两个函数，这样可以屏蔽掉很多源代码中不是很重要的细节。

这个get in from item
om函数就是用当前算出来的哈希值求出下一个要读取的位置。然后make
item函数用cache中这个位置的数和当前的哈希值计算出下一个哈希值。这样迭代256轮，最后得到一个64字节的哈希值。作为大数据集中的第二个元素。这个calculate
data
set是生成整个一G数据集的过程，就是不断的调用前面这个函数来依次生成大数据集中的每个元素。

这一页的两个函数分别是矿工用来挖矿的函数和清洁点用来验证的函数。我们先看一下上面这个函数，这个矿工用来挖矿的函数，它有四个参数。Header是当前要生成的这个区块的块头。以太坊跟比特币一样，挖矿只用到块头的信息，大家还记得这样设计的原因吗？

就为什么要设计成挖矿，只用块头的信息。这样的话，清洁点只下载块头就可以验证这个区块是否符合挖矿的难度要求。第二个参数nance就是当前尝试的nance值。以太坊就像比特币一样，挖矿的时候也是要尝试大量的纳，才能找到一个符合要求的。

第三个参数夫赛是大数据集中元素的个数。这个元素的个数每3万个区块会增加一次，增加原始大小的128分之1，也就是一致的128分之1等于8兆。最后这个参数data
set就是前面生成的那个大数据集。

挖矿的过程是这样的，首先根据块头的信息和当前的纳算出一个初始的哈希值。然后要经过64轮的循环，每一轮循环读取大数据，集中两个相邻的数，读取的位置是由当前哈希值计算出来的。然后再根据这个位置上的数值来更新当前的哈希值，这跟前面生成大数据集时的方法是类似的。循环64次，最后返回一个哈希值，用于跟挖矿难度的目标阈值相比较。这里我们提了个小问题，每次读取大数据集中两个相邻位置的哈希纸，这两个哈希值有什么联系吗？

是没有关系的。就这两个哈希值虽然在位置上是相邻的，但是生成的过程是独立的。每个都是由前面那个16兆的c中的256个数生成的，而且这256个数的位置是按照尾随机的顺序产生的，这个是构造大数据集的一个重要特点。每个元素独立生成，这才给清洁碱的验证提供了方便，所以每次读取的这两个相邻位置的哈希值是没有什么联系的。

下面这个函数是清洁点用来验证的函数，也是有四个参数，但是含义跟上面那个矿工用的函数有所不同。清洁点是不挖矿的当他收到某个矿工发布的一个区块的时候，这里用来验证的这个函数的第一个参数hi是这个区块的块头。第二个参数n是包含在这个块头里的nas是发布这个区块的矿工选好的清节点的任务是验证这个n是否符合要求，验证用的是16兆的cache，也就是最后这个参数，这个cache注意。第三个参数，复赛仍然是大数据集的元素个数，跟上面那个挖矿用的函数里的负size的含义是一样的，这个并不是cache中的元数个数。验证的过程也是64轮循环，看上去与挖矿的过程类似，只有一个地方有区别，大家看出来了吗？就比较一下这一页的两个函数，上下两个函数有什么区别。

每次需要从大数据集中读取元素的时候，因为清洁点没有保留大数据集，所以要从cache中重新生成其他地方的代码，逻辑是一样的。每次从当前的哈希值算出要读取的元素的位置，这个位置是指在大数据集中的位置，但是清洁点并没有这个大数据集，所以要从cac中生成大数据集中这个位置的元素。我们前面说过，大数据集中每个位置的元素都可以独立生成出来。

最后这个函数是矿工挖矿的主循环，其实就是不断尝试各个n的过程，这里的target就是挖矿的难度，目标跟比特币类似，也是可以动态调整的，n的可能取值是从0到2的64次方。对每个n用前面讲的那个函数算出一个哈希值，看看是不是小于难度目标，如果不行的话，那么就再试下一个。

最后这一页是前面讲过的所有函数的一个汇总，同时解释了为什么清洁点可以只保存cache，而矿工要保存整个大数据集。大家能看明白上面的解释吗？

这个能看明白吗？其实清洁点做一次验证了计算量也不算少，同样要经过64轮循环，每次循环用到大数据集中的两个数，所以一共是128个数，每个数是从c里的256个数计算得到的。跟比特币相比，以太坊中验证一个的计算量要大很多，但是仍然在可以接受的范围内。相比之下，矿工如果每次都这么折腾的话，代价就太大了，因为要尝试的nice太多了。

那以太坊设计的这个pudle实际效果怎么样呢？到目前为止，以太坊挖矿主要还是以制pu为主，用ac克矿机的很少。所以从这一点上来说，他比莱特币要成功，起到了asic
resistant的作用。这个跟以太坊这个挖矿算法需要的大内存是很有关系的，就这个算法叫做。

Yes
has以太坊的挖矿算法这个名字起的很有意思。前三个字母一是以太坊的代码叫et
th后面这个hash
H是用了两遍意思hash。矿工挖矿需要一G的内存，跟莱特币的128K比。这个差了有八千多倍。即使你这个16兆的。跟这个128K比也要大了一百多倍，所以这个差距是很大的。而且这个还是按照这两个数据集的最初的大小来算的，因为它定期会增长。你要按照现在这个大数据基2.5G来算的话，这差距就更大了。

以太坊没有出现埃个矿机。还有另外一个原因，就以太坊从很早就开始计划要从工作量证明转向权益证明。就所谓的从这个proof
of work转向proof of stake，这个我们以前提到过一下。

所谓的权益证明就是按照所占的权益进行投票来形成共识，就不用挖矿了。权益证明是不挖矿的，就类似于股份制公司按照股票多少来进行投票。这个对于A矿机的厂商来说是个很大的威胁。因为ac个芯片的研发周期是很长的，一款芯片从设计、研发、流片到最后生产出来，一年的周期就已经算是很快的了，而且研发的成本也很高。那么将来以太坊转入权益证明之后就不挖矿了，那么这些投入的研发费用就都白费了。其实以太坊到现在为止还是基于工作量证明。

以太坊很早就说要转入权益证明，但是转移的时间点一再的往后推迟，到现在也没转过来。但是他不停的宣称要怎么做，所以要想达到asic
resistance，一个简单的办法就是不断的吓唬大家。大家注意，我可说了，我们下面要搞权益证明。是不挖矿，所以你就不要设计A个矿机了，你设计出来到时候也没用了，因为你设计到一年，我们一年以后就不挖矿，那等过了一年发现不行，还是得继续挖矿，那怎么办呢？再吓唬一次，我们最多再挖一年，然后真的就是不挖了，所以你还是不要再设计了，不要搞ac的芯片。大家如果看一下历史的话，以太坊成为一个主流的加密货币，其实就是最近两年的事情。以前市值很小的时候，没有人会去设计A芯片，因为划不来，无利可图。等到市值上来之后，你这么吓唬他几次，就能起到asic
resistance的作用，这也是另外一方面的原因。关于以太坊的挖矿，还有一个要说明的就是以太坊当中采用了预挖矿的过程。

叫pre所。谓的预挖矿，并不是说真的去挖矿，而是说在当初发行货币的时候，预留一部分货币给以太坊的开发者。就有点像创业公司会留一部分股票给创始人和早期员工一样。将来这个加密货币成功了的话，这些预留的币就变得是很值钱了。像以太坊的早期开发者现在就都很有钱，比北大教授要有钱多了。那么跟这个比特币相比，比特币就没有采用preman的模式，所有的比特币都是挖出来的，只不过早期的时候挖矿的难度要容易得多。与pri相关的一个概念叫Preil。

就是把preding当中预留的那些币通过出售的方法来换取一些资产，然后用于加密货币的开发工作，就有点类似于像拉风投或者众筹。如果你看好这个加密货币的未来，那么可以在Preil的时候买入，将来这个加密货币成功之后，同样可以赚很大一笔钱。大家有问题吗？

那下面我们看一下以太坊上的一些统计数据。

这个图显示了以太坊中货币供应量的分布情况，总共有大约1亿个以太币，每个以太币的市场价格是五百多美元。这里的数据是两个月前的，现在以太币的价格已经降到460多美元了，整个以太坊的市值大概是五百多亿美元。下面这个图显示了这一亿个以太币的来源，绝大部分是通过preman的方法产生的。这个蓝色部分genes是指创世纪块中就已经包含了这些以太币上线以后再挖出来的以台币中，block
reward占了绝大多数，uncle
reward就是上节课讲的舒服区块得到了奖励，只占很少一部分。大家看到这些有什么感想？有没有觉得毁三观？挖矿挖得再努力，关键还是不能输在起跑线上。这个图显示的是最大的25个以太坊矿池所占的算力比重。可以看出，挖矿集中化的程度也是很高的，尤其是最大的几个矿池所占的比例很高，与比特币的情况类似。

这个图显示的是以太币的价格随时间变化的情况。我们可以看到在以太坊早期的那几年，价格基本没怎么涨，真正的大涨是去年才开始的。2017年这一年价格涨得非常猛，直到今年初达到了顶峰，一千三四百美元，然后开始走下坡路。

这个图显示的是以太坊的市值，叫market
capitalization，这个跟上一页刚才显示的价格的走势基本上是符合的。这个图显示的是以太坊的哈sh瑞的变化情况。我们前面讲过hash
rate是指系统中所有的矿工加在一起每秒钟计算的哈希次数。可以看到hash
rate从总体来说是处于上升趋势的，而且也是从去年开始大幅度上升的。今年以太币的价格下跌了不少，hash
rate总体上趋于平稳，并没有出现明显的下。

降。

大家注意不同的加密货币如果采用的minpuzzle不一样的话，那么他们的hash
rate是不可比的。比特币和以太坊的哈sh瑞就不能直接比较，因为以太坊中尝试一个n的工作量要比比特币大得多。

同学们有什么问题吗？最后我再说明一点，到目前为止，我们这节课上讲的都是挖矿的算法设计。要尽可能的让通用计算设备也能够参加。参加的人越多，挖矿的过程越民主，那么区块链就越安全。这也是为什么莱特币以太坊要设计这种memory
hard的padle。但是也有一些人有不同的观点，认为让通用计算设备参与挖矿反而是不安全的，像比特币那样只能用专门的a芯片挖矿才是更安全的，为什么呢？你们谁能猜一下吗？

其实意思是攻击比特。

币的成本会比较高。

但是如果是每个人的电脑都可以起到这样的。这个说的很对，就假设你要对比特币系统发动攻击，你应该怎么做？你需要投入大量的资金买入这些AC克矿机，这样才能够聚集到发动攻击所需要的算力，而这些矿机除了挖矿之外，干不了别的任何事情，而且是为某一个假密货币设计的挖矿芯片。只能挖这种加密货币，像比特币的ac的芯片，你去挖埋特币就不行。所以发动这个攻击的成本是很高的。

早期需要投入大量的硬件资源，而且一旦攻击成功之后会出现什么情况？比特币系统的安全性被证明存在问题，大家对比特币的信心会大幅度下跌，然后比特币的价格也会跳水，这样早期投入的硬件成本就收不回来了。你比特币本身都不值钱了，你买的那些比特币的矿机当然也不值钱。

相反的，如果让通用计算设备能参与挖矿的话，那么发动攻击的成本就大幅度下降。因为没有必要为了发动攻击而去专门购买特制的硬件设备。比如说有很多大公司，大的互联网公司，它在全世界的服务器有几十万台甚至上百万台。那么需要发动攻击的时候怎么办呢？只需要把这些服务器调动起来，都来挖矿就行了，就平时这些服务器可能是为了满足公司的日常业务而服务的。攻击的时候临时征用起来用来挖矿，没有必要专门买特制的设备。那么攻击结束之后，这些服务器又可以恢复原来的用途，该干嘛就干嘛。这样的话，发动攻击的成本就大幅度下降了。

当然了，你可能说这种大型的互联网巨头不会干这种事情。就是会不会说有哪个公司觉得某个区块链不好，这个区块链上有什么应用妨案它的业务发展会不会干这种事情？即使这个互联网公司本身不干这种事情，有恶意的那些攻击者，某些组织机构也有可能通过云服务来租用这些服务器集群，达到同样的目的。所以有些人就认为让通用设备参与挖矿是不好的，ac个矿机一统天下才是最安全的。大家有问题吗？没有问题，我们这节课就上到这了，好吧。
